import java.util.List;
import java.util.ArrayList;

import static org.junit.Assert.*;
import org.junit.Test;

import com.maxeler.maxcompiler.v2.managers.standard.SimulationManager;
import com.maxeler.maxcompiler.v2.utils.Bits;


public class ConvolutionSchedulerKernelTest {

    protected interface StreamChecker {
        public void prepare(ConvolutionParameters params);
        public void check(int w, int p, int x, int c, int y, int idx);
    }

    /**
     * Generates a pure-pseudorandom number purely based on the
     * outputChannel and inputChannel of this kernel.
     *
     * The purpose of this is to generate kernels
     * in a dsterminisitc manner and can test whether they are
     * scheduled correctly by the scheduler.
     */
    protected float[][] generateSingleKernel(
            int outputChannel,
            int inputChannel,
            int kernelDim) {

        float[][] kernel = new float[kernelDim][kernelDim];

        for (int i = 0 ; i < kernelDim ; i++) {
            for (int j = 0 ; j < kernelDim ; j++) {
                kernel[i][j] =
                    outputChannel * 0.425372f
                    + inputChannel *  0.5387549f
                    + i * -0.538432f
                    + j * -0.12324f;
            }
        }

        return kernel;
    }

    protected List<List<float[][]>> generateRandomKernels(
            int numberOfOutputChannels,
            int numberOfInputChannels,
            int kernelDim) {
        List<List<float[][]>> ret = new ArrayList<List<float[][]>>();

        for (int o = 0 ; o < numberOfOutputChannels ; o++) {
            ArrayList<float[][]> l = new ArrayList<float[][]>();

            for (int i = 0 ; i < numberOfInputChannels ; i++) {
                l.add(generateSingleKernel(o, i, kernelDim));
            }

            ret.add(l);
        }

        return ret;
    }

    protected float getPixelValue(Dimension dim, int row, int col, int channel) {
        return (0.001f * 
            (row * dim.width() * dim.channels()
            + col * dim.channels()
            + channel));
    }

    protected List<Float>  generatePixels(Dimension dim, int numberOfImages) {

        List<Float> ret = new ArrayList<Float>();

        for (int t = 0 ; t < numberOfImages ; t++) {
            for (int i = 0 ; i < dim.height() ; i++) {
                for (int j = 0 ; j < dim.width() ; j++) {
                    for (int c = 0 ; c < dim.channels() ; c++) {
                        ret.add(getPixelValue(dim, i, j, c));
                    }
                }
            }
        }

        return ret;
    }

    protected void checkStream(
            StreamChecker checker,
            ConvolutionSchedulerKernel kernel,
            ConvolutionParameters params,
            int convUnitId,
            List<Float> output) {

        int outputWindowSize = params.outputDimension().width() * params.outputDimension().height();
        int kernelFoldingFactor = params.kernelFoldingFactor;
        int loopIterations = kernel.getLoopIterations();
        int convLoopIterations = kernel.getConvLoopIterations();

        /*
         * every [kernelDim * kernelDim] elements corresponds to the
         * slidingWindow that ConvolutionUnit that will receive.
         * we expect that the number of slidingWindows that we should receive
         * must be a multiple of denom below.
         * [indices.size() * convolultionOutputWindow_size * kernelDim * kernelDim]
         */

        int denom = (loopIterations * convLoopIterations
                * outputWindowSize
                * kernelFoldingFactor);
        assertTrue(
                "weightsOutput.size() must be a multiple of " +
                "(loopIterations * convLoopIterations * outputWindowSize " + 
                "kernelFoldingFactor)",
                output.size() % denom == 0);

        int numberOfWindows = output.size() / denom;
        checker.prepare(params);

        for (int w = 0 ; w < numberOfWindows ; w++) {
            for (int p = 0 ; p < outputWindowSize ; p++) {
                for (int x = 0 ; x < loopIterations ; x++) {
                    for (int c = 0 ; c < convLoopIterations ; c++) {
                        for (int y = 0 ; y < kernelFoldingFactor ; y++) {
                            int idx = w * (outputWindowSize * loopIterations
                                           * convLoopIterations
                                           * kernelFoldingFactor)
                                      + p * (loopIterations
                                              * convLoopIterations
                                              * kernelFoldingFactor)
                                      + x * (convLoopIterations
                                              * params.kernelFoldingFactor)
                                      + c * params.kernelFoldingFactor
                                      + y;

                            checker.check(w, p, x, c, y, idx);
                        }
                    }
                }
            }
        }
    }

    protected void checkPixelsOutput(
            final ConvolutionSchedulerKernel kernel,
            final ConvolutionParameters params,
            final int convUnitId,
            final List<Float> pixelsOutput) {
        StreamChecker checker = new StreamChecker() {
            private List<Float> pixelsOutput;
            private ConvolutionParameters params;
            private List<ConvChannelIndex> indices;
            private int kernelFoldingFactor, kernelDim;

            public void prepare(
                    ConvolutionParameters argParams) {
                params = argParams;
                indices = kernel.getConvUnitChannelIndices(convUnitId);
                kernelFoldingFactor = params.kernelFoldingFactor;
                kernelDim = params.kernelDim;
            }

            public void check(int w, int p, int x, int c, int y, int idx) {
                if (x < indices.size()) {
                    int width = params.outputDimension().width();
                    int kernelIndex = c * kernelFoldingFactor + y;
                    int row = (p / width) + (kernelIndex / kernelDim);
                    int col = (p % width) + (kernelIndex % kernelDim);
                    int channel = indices[x].in;

                    float expectedPixel = getPixelValue(
                            params.inputDimension(), row, col, channel);

                    float delta = Math.abs(pixelsOutput[idx] - expectedPixel);
                    assertTrue(delta < 0.01f);

                } else {
                    assertTrue(Math.abs(pixelsOutput[idx]) < 0.01f);
                }
            }
        };
        checkStream(checker, kernel, params, convUnitId, pixelsOutput);
    }

    protected int calcPixelRow(Dimension dim, int kernelDim, int pixelIndex, int kernelIndex) {
        int row = pixelIndex / dim.width();
        return row + kernelIndex / kernelDim;
    }

    protected int calcPixelCol(Dimension dim, int kernelDim, int pixelIndex, int kernelIndex) {
        int col = pixelIndex % dim.width();
        return col + kernelIndex % kernelDim;
    }

    protected void checkWeightsOutput(
            final ConvolutionSchedulerKernel kernel,
            final ConvolutionParameters params,
            final int convUnitId,
            final List<Float> weightsOutput) {

        StreamChecker checker = new StreamChecker() {
            private List<List<float[][]>>  generatedKernels;
            private List<ConvChannelIndex> indices;
            private int kernelFoldingFactor, kernelDim;

            public void prepare(ConvolutionParameters params) {
                indices = kernel.getConvUnitChannelIndices(convUnitId);
                kernelFoldingFactor = params.kernelFoldingFactor;
                generatedKernels = generateRandomKernels(
                        params.outputDimension().channels(),
                        params.inputDimension().channels(),
                        params.kernelDim);
                kernelDim = params.kernelDim;
            }

            public void check(int w, int p, int x, int c, int y, int idx) {
                if (x < indices.size()) {
                    int i = y + c * kernelFoldingFactor;
                    float expectedWeight = generatedKernels
                        .get(indices[x].out)
                        .get(indices[x].in)
                        [i / kernelDim][i % kernelDim];

                    float delta = Math.abs(weightsOutput[idx] - expectedWeight);
                    assertTrue(delta < 0.01f);

                } else {
                    assertTrue(Math.abs(weightsOutput[idx]) < 0.01f);

                }
            }
        };
        checkStream(checker, kernel, params, convUnitId, weightsOutput);
    }

    protected void genericTest(String testName, final int foldingFactor) {
        final int numberOfImages = 10;
        final int kernelDim = 5;
        final int outputChannels = 10;
        final int inputChannels = 20;
        final int kernelFoldingFactor = 5;
        final Dimension inputDim = new Dimension(
                30, 30, inputChannels);
        final int outputWindowSize =
            (inputDim.height() - (kernelDim - 1))
            * (inputDim.width() - (kernelDim - 1));

        ConvolutionParameters params = new ConvolutionParameters();
        params.inputDim = inputDim;
        params.kernelDim = kernelDim;
        params.outputChannels = outputChannels;
        params.foldingFactor = foldingFactor;
        params.kernelFoldingFactor = kernelFoldingFactor;
        params.kernels = generateRandomKernels(
                outputChannels, inputChannels, kernelDim);

        SimulationManager manager = new SimulationManager(testName + "Kernel");
        ConvolutionSchedulerKernel kernel =
            new ConvolutionSchedulerKernel(
                    manager.makeKernelParameters(testName),
                    params);
        manager.setKernel(kernel);
        manager.build();

        List<Float> pixelsInput = generatePixels(inputDim, numberOfImages);
        List<Bits> rawPixelsInput = TestHelper.toBitsList(
                pixelsInput, inputDim.channels());

        manager.setInputDataRaw(kernel.getInputName(), rawPixelsInput);
        manager.setKernelCycles(
                numberOfImages * inputDim.height()
                * inputDim.width()
                * kernel.getLoopIterations()
                * kernel.getConvLoopIterations());
        manager.run();

        for (int convUnitId = 0 ; convUnitId < foldingFactor ; convUnitId++) {
            List<Bits> rawWeightsOutput = manager.getOutputDataRaw(
                    kernel.getWeightOutputName(convUnitId));
            List<Bits> rawPixelsOutput = manager.getOutputDataRaw(
                    kernel.getPixelOutputName(convUnitId));

            List<Float> pixelsOutput = TestHelper.fromBitsList(
                    rawPixelsOutput, kernelFoldingFactor);
            List<Float> weightsOutput = TestHelper.fromBitsList(
                    rawWeightsOutput, kernelFoldingFactor);
            int expectedOutputSize = (numberOfImages
                    * outputWindowSize
                    * kernelFoldingFactor
                    * kernel.getLoopIterations()
                    * kernel.getConvLoopIterations());

            assertEquals(expectedOutputSize, pixelsOutput.size());
            assertEquals(expectedOutputSize, weightsOutput.size());
            checkWeightsOutput(kernel, params, convUnitId, weightsOutput);
            checkPixelsOutput(kernel, params, convUnitId, pixelsOutput);
        }
    }

    @Test
    public void testModerateFoldingFactor() {
        genericTest("testModerateFoldingFactor", 10);
    }

    @Test
    public void testNonMultipleFoldingFactor() {
        genericTest("testNonMultipleFoldingFactor", 9);
    }
}
