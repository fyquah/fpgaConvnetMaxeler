import org.junit.Test;
import static org.junit.Assert.*;
import org.junit.runner.Result;
import java.util.List;
import java.util.ArrayList;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.managers.standard.SimulationManager;
import com.maxeler.maxcompiler.v2.utils.Bits;

public class TestPoolingLayerKernel {

    @Test
    public void testEvenDim() {
        for (int kernelDim = 2; kernelDim <= 4 ; kernelDim += 2) {
            SimulationManager manager = new SimulationManager("PoolingTest");
            Dimension inputDimension = new Dimension(28, 28, 1);
            PoolingParameters poolingParams = new PoolingParameters(
                    inputDimension, kernelDim, PoolingUnit.Type.Max);
            PoolingLayerKernel kernel = new PoolingLayerKernel(
                    manager.makeKernelParameters(), poolingParams);

            // manager.logInfo("Seed: %d", seed);
            manager.setKernel(kernel);
            manager.build();

            ArrayList<Bits> x = new ArrayList<Bits>();
            ArrayList<Double> ori_x = new ArrayList<Double>();

            for (int i = 0 ; i < 28 ; i++) {
                for (int j = 0 ; j< 28 ; j++) {
                    ori_x.add((double) 0.01 * (i + j));
                    x.add(Utils.doubleToBits((double) 0.01 * (i + j)));
                }
            }

            manager.setInputDataRaw("x", x);
            manager.setKernelCycles(x.size());
            manager.run();
            List<Bits> y = manager.getOutputDataRaw("y");
            List<Double> ey = new ArrayList<Double>();

            for (int r = 0 ; r < 28 ; r++) {
                for (int c = 0 ; c < 28 ; c++) {
                    if ((r - kernelDim / 2) % kernelDim == 0 &&
                            (c - kernelDim / 2) % kernelDim == 0) {
                        double m = 0.0;

                        for (int i = -kernelDim / 2 ; i < kernelDim /2 ; i++) {
                            for (int j = -kernelDim / 2 ; j < kernelDim /2 ; j++) {
                                m = Math.max(ori_x[(r + i) + 28 * (c + j)], m);
                            }
                        }

                        ey.add(m);
                    }
                }
            }

            assertTrue(ey.size() == y.size());
            for (int t = 0 ; t < y.size() ; t++) {
                double d = Math.abs(ey[t]  - Utils.bitsToDouble(y[t]));
                assertTrue(d < 0.1);
            }
        }
    }

    @Test
    public void testOddDim() {
        int[] kernelDims = new int[]{3, 7};

        for (int k = 0 ; k < kernelDims.length ; k++) {
            int kernelDim = kernelDims[k];
            int inputHeight = kernelDim * 5;
            int inputWidth = kernelDim * 5;
            SimulationManager manager = new SimulationManager("PoolingTest");
            Dimension inputDimension = new Dimension(inputHeight, inputWidth, 1);
            PoolingParameters poolingParams = new PoolingParameters(
                    inputDimension, kernelDim, PoolingUnit.Type.Max);
            PoolingLayerKernel kernel = new PoolingLayerKernel(
                    manager.makeKernelParameters(), poolingParams);

            // manager.logInfo("Seed: %d", seed);
            manager.setKernel(kernel);
            manager.build();

            ArrayList<Bits> x = new ArrayList<Bits>();
            ArrayList<Double> ori_x = new ArrayList<Double>();

            for (int i = 0 ; i < inputHeight ; i++) {
                for (int j = 0 ; j< inputWidth ; j++) {
                    ori_x.add((double) 0.01 * (i + j));
                    x.add(Utils.doubleToBits((double) 0.01 * (i + j)));
                }
            }

            manager.setInputDataRaw("x", x);
            manager.setKernelCycles(x.size());
            manager.run();
            List<Bits> y = manager.getOutputDataRaw("y");
            List<Double> ey = new ArrayList<Double>();

            for (int r = 0 ; r < inputHeight ; r++) {
                for (int c = 0 ; c < inputWidth ; c++) {
                    if ((r - kernelDim / 2) % kernelDim == 0 &&
                            (c - kernelDim / 2) % kernelDim == 0) {
                        double m = 0.0;

                        for (int i = - (kernelDim / 2) ; i <= kernelDim / 2 ; i++) {
                            for (int j = -(kernelDim / 2) ; j <= kernelDim /2 ; j++) {
                                m = Math.max(ori_x[(r + i) * inputWidth + (c + j)], m);
                            }
                        }

                        ey.add(m);
                    }
                }
            }

            assertTrue(y.size() == ey.size());
            for (int t = 0 ; t < y.size() ; t++) {
                double d = Math.abs(ey[t]  - Utils.bitsToDouble(y[t]));
                assertTrue(d < 0.1);
            }
        }
    }
}

