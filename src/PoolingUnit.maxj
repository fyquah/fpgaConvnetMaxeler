// package nothing;

import maxpower.ops.AssociativeOp;
import maxpower.utils.TreeReduce;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

public class PoolingUnit extends KernelLib {
    public enum Type {
        Max, Average
    }

    private final DFEVar output_;
    private final DFEVar row, col, rowStride, colStride;
    private final DFEVar input;
    private final Kernel kernel;
    private final SlidingWindow slidingWindow;
    private final int inputHeight, inputWidth, kernelDim;
    private final AssociativeOp<DFEVar> op;
    private static final AssociativeOp<DFEVar> dfeMaxOp = new AssociativeOp<DFEVar>(){
        @Override
        public DFEVar op(DFEVar a, DFEVar b) { return a > b ? a : b; }
    };
    private static final AssociativeOp<DFEVar> dfeSumOp = new AssociativeOp<DFEVar>() {
        @Override
        public DFEVar op(DFEVar a, DFEVar b) { return a + b; }
    };

    public PoolingUnit (Kernel argKernel, Type type, int argInputHeight, int argInputWidth, int argKernelDim) {
        super(argKernel);

        kernel = argKernel;
        inputHeight = argInputHeight;
        inputWidth = argInputWidth;
        kernelDim = argKernelDim;
        input = GlobalConfig.dataType.newInstance(this);
        slidingWindow = new SlidingWindow(
            kernel,
            input,
            inputHeight, inputWidth, kernelDim,
            1
        );
        CounterChain chain = control.count.makeCounterChain();
        row = chain.addCounter(inputHeight, 1);
        col = chain.addCounter(inputWidth, 1);

        Counter colStrideCtr = control.count.makeCounter(
            control.count.makeParams(Utils.ceilLog2(kernelDim))
                .withMax(kernelDim)
                .withInc(1)
                .withInitValue((kernelDim + 1) / 2)
                .withWrapMode(Count.WrapMode.COUNT_LT_MAX_THEN_WRAP)
        );
        colStride = colStrideCtr.getCount();

        Counter rowStrideCtr = control.count.makeCounter(
            control.count.makeParams(Utils.ceilLog2(kernelDim))
                .withMax(kernelDim)
                .withInc(1)
                .withInitValue((kernelDim + 1) / 2)
                .withWrapMode(Count.WrapMode.COUNT_LT_MAX_THEN_WRAP)
                .withEnable(col.eq(inputWidth - 1))
        );
        rowStride = rowStrideCtr.getCount();

        switch (type) {
        case Average:
            op = dfeSumOp;
            output_ = TreeReduce.reduce(op, slidingWindow.asList()) / (kernelDim * kernelDim);
            break;
        case Max:
        default:
            op = dfeMaxOp;
            output_ = TreeReduce.reduce(op, slidingWindow.asList());
            break;
        }
    }

    protected void debugDump(List<DFEVar> input, DFEVar output) {
        debug.simPrintf("[%d] ", isValidStride());
        for (int i = 0 ; i < input.size() ; i++) {
            debug.simPrintf("%.5f ", input[i]);
        }
        debug.simPrintf("-> %.5f\n", output);
    }

    public void setInput(DFEVar x) {
        input <== x;
    }

    public DFEVar output() {
        return output_;
    }

    private DFEVar isBorder() {
        DFEVar flag = constant.var(dfeBool(), 0);

        if (kernelDim % 2 == 1) {
            for (int i = 0 ; i < (kernelDim - 1) / 2 ; i++) {
                flag = flag | row.eq(i) | col.eq(i)
                        | row.eq(inputHeight - 1 - i)
                        | col.eq(inputWidth - 1 - i);
            }

            return flag;
        } else {
            // handle top and left first
            for (int i = 0 ; i < kernelDim / 2 ; i++) {
                flag = flag | row.eq(i) | col.eq(i);
            }

            // handle bottom and right
            for (int i = 0 ; i < (kernelDim / 2) - 1 ; i++) {
                flag = flag | row.eq(inputHeight - 1 - i)
                        | col.eq(inputWidth - 1 - i);
            }

            return flag;
        }
    }

    private DFEVar isValidStride() {
        return rowStride.eq(0) & colStride.eq(0);
    }

    public DFEVar isOutputReady() {
        return ~isBorder() & isValidStride();
    }
}
