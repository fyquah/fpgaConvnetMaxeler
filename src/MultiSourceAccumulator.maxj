// package nothing;

import java.util.ArrayList;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;

public class MultiSourceAccumulator extends KernelLib {
    private boolean generated = false;
    private DFEVar out;
    public ArrayList<DFEVar> sources;
    public int addCycles, holdCycles;
    public OffsetExpr cycleLength, pipelineLength;
    public static OffsetExpr pipelineLengthCache = null;
    public DFEVar cycleLengthVar, iter, cycleStage, pipelineIndex, pipelineLengthVar;

    public OffsetExpr getOffsetAutoLoop() {
        if (pipelineLengthCache == null) {
            pipelineLengthCache = stream.makeOffsetAutoLoop("MultiSourceAccumulator", 1, 120);
            // pipelineLengthCache = new OffsetExpr(1);
        }

        return pipelineLengthCache;
    }

    public MultiSourceAccumulator (
            Kernel argKernel,
            int argAddCycles,
            int argHoldCycles,
            OffsetExpr argCycleLength) {
        super(argKernel);
        addCycles = argAddCycles;
        holdCycles = argHoldCycles;
        sources = new ArrayList<DFEVar>();
        out = GlobalConfig.dataType.newInstance(this);
        cycleLength = argCycleLength;
        cycleLengthVar = cycleLength.getDFEVar(this, dfeUInt(8));
        pipelineLength = getOffsetAutoLoop();
        pipelineLengthVar = pipelineLength.getDFEVar(this, dfeUInt(8));
        pipelineIndex = Utils.simpleCounter(this, pipelineLengthVar, 1);

        CounterChain chain = control.count.makeCounterChain();
        iter = Utils.chainCounterOrZero(argKernel, chain, argHoldCycles);
        cycleStage = chain.addCounter(cycleLengthVar, 1);

        if (argAddCycles < argHoldCycles) {
            System.out.println("addCycles cannot be < holdcycles!");
            System.exit(-1);
        }
    }

    public DFEVar pipelineStart() {
        return pipelineIndex.eq(0);
    }

    public DFEVar pipelineEnd() {
        return pipelineIndex.eq(pipelineLengthVar - 1);
    }

    public void addSource(DFEVar x) {
        sources.add(x);
    }

    public void generate(double pipeliningFactor) {
        // Compute previous (either 0 or output[-1])
        optimization.pushPipeliningFactor(pipeliningFactor);
        DFEVar prev = iter.eq(0) ? constant.var(GlobalConfig.dataType, 0) :
            stream.offset(out, -cycleLength);

        // compute the new input
        ArrayList<DFEVar> adderInputs = Utils.dupArrayList(sources, prev);

        // Decide whether to show previous / updated input
        if (addCycles == holdCycles) {
            out <== (cycleStage.eq(cycleLengthVar - 1)
                ? Utils.treeReduceAdd(adderInputs)
                : prev);
        } else {
            out <== ((cycleStage.eq(cycleLengthVar - 1) | iter >= addCycles)
                ? Utils.treeReduceAdd(adderInputs)
                : prev);
        }

        // set the flag
        generated = true;
        optimization.popPipeliningFactor();
    }

    public DFEVar output() {
        return out;
    }
}
