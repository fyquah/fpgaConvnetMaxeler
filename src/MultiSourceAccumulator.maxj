// package nothing;

import java.util.ArrayList;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

public class MultiSourceAccumulator extends KernelLib {
    private boolean generated = false;
    private DFEVar out;
    public ArrayList<DFEVar> sources;
    public int addCycles, holdCycles, cycleLength;
    public DFEVar iter, cycleStage;

    public MultiSourceAccumulator (Kernel argKernel,
            int argAddCycles, int argHoldCycles, int argCycleLength) {
        super(argKernel);
        addCycles = argAddCycles;
        holdCycles = argHoldCycles;
        sources = new ArrayList<DFEVar>();
        out = GlobalConfig.dataType.newInstance(this);
        cycleLength = argCycleLength;

        if (cycleLength == 1) {
            if (argHoldCycles == 1) {
                iter = constant.var(dfeBool(), 0);
                cycleStage = constant.var(dfeBool(), 0);
            } else {
                iter = control.count.simpleCounter(Utils.ceilLog2(argHoldCycles), argHoldCycles);
                cycleStage = constant.var(dfeBool(), 0);
            }
        } else {
            CounterChain chain = control.count.makeCounterChain();

            if (argHoldCycles == 1) {
                iter = constant.var(dfeBool(), 0);
            } else {
                iter = chain.addCounter(argHoldCycles, 1);
            }

            cycleStage = chain.addCounter(cycleLength, 1);
        }

        if (argAddCycles < argHoldCycles) {
            System.out.println("addCycles cannot be < holdcycles!");
            System.exit(-1);
        }
    }

    public void addSource(DFEVar x) {
        sources.add(x);
    }

    public void generate(double pipeliningFactor) {
        // Compute previous (either 0 or output[-1])
        optimization.pushPipeliningFactor(pipeliningFactor);
        DFEVar prev = iter.eq(0) ? constant.var(GlobalConfig.dataType, 0) :
            stream.offset(out, -cycleLength);

        // compute the new input
        ArrayList<DFEVar> adderInputs = Utils.dupArrayList(sources, prev);

        // Decide whether to show previous / updated input
        if (addCycles == holdCycles) {
            out <== cycleStage.eq(cycleLength - 1) ? Utils.treeReduceAdd(adderInputs) : prev;
        } else {
            out <== (cycleStage.eq(cycleLength - 1) | iter >= addCycles)
                ? Utils.treeReduceAdd(adderInputs) : prev;
        }

        // set the flag
        generated = true;
        optimization.popPipeliningFactor();
    }

    public DFEVar output() {
        return out;
    }
}
