// package nothing;

import java.util.ArrayList;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;

public class MultiSourceAccumulator extends KernelLib {
    /*
     * convPipelineLength is the number of cycles that ConvolutionUnit will require
     * to generate an output. Right now, we do not assume that ConvolutionUnit
     * is in any sense pipelined.
     * */
    private boolean generated = false;
    private DFEVar out;
    private Kernel kernel;
    public ArrayList<DFEVar> sources;
    public int addCycles, holdCycles;
    public OffsetExpr convPipelineLength, pipelineLength;
    public DFEVar convPipelineLengthVar, iter, cycleStage, pipelineIndex, pipelineLengthVar;
    /* offsetdefaultdict ensures that every kernel has only one offsetexpr, which
     * should be perfectly sensible since there is only one output per kernel */
    public static OffsetExprDefaultDict pipelineLengthCache = new OffsetExprDefaultDict(
            "MultiSourceAccumulator");

    public OffsetExpr getOffsetAutoLoop() {
        return pipelineLengthCache.get(kernel);
    }

    public MultiSourceAccumulator (
            Kernel argKernel,
            int argAddCycles,
            int argHoldCycles,
            OffsetExpr argCycleLength) {
        super(argKernel);
        kernel = argKernel;
        addCycles = argAddCycles;
        holdCycles = argHoldCycles;
        sources = new ArrayList<DFEVar>();
        out = GlobalConfig.dataType.newInstance(this);
        convPipelineLength = argCycleLength;
        convPipelineLengthVar = convPipelineLength.getDFEVar(this, dfeUInt(8));
        pipelineLength = getOffsetAutoLoop();
        pipelineLengthVar = pipelineLength.getDFEVar(this, dfeUInt(8));
        pipelineIndex = Utils.simpleCounter(this, pipelineLengthVar, 1);

        CounterChain chain = control.count.makeCounterChain();
        iter = Utils.chainCounterOrZero(argKernel, chain, argHoldCycles);
        cycleStage = chain.addCounter(convPipelineLengthVar, 1);

        if (argAddCycles < argHoldCycles) {
            System.out.println("addCycles cannot be < holdcycles!");
            System.exit(-1);
        }
    }

    public void addSource(DFEVar x) {
        sources.add(x);
    }

    public void generate(double pipeliningFactor) {
        // Compute previous (either 0 or output[-1])
        optimization.pushPipeliningFactor(pipeliningFactor);
        OffsetExpr offset = -(convPipelineLength + pipelineLength);
        DFEVar prev = (iter.eq(0)
                ? constant.var(GlobalConfig.dataType, 0)
                : stream.offset(out, offset));

        // compute the new input
        ArrayList<DFEVar> adderInputs = Utils.dupArrayList(sources, prev);

        // Decide whether to show previous / updated input
        if (addCycles == holdCycles) {
            out <== (cycleStage.eq(convPipelineLengthVar - 1)
                ? Utils.treeReduceAdd(adderInputs)
                : prev);
        } else {
            out <== ((cycleStage.eq(convPipelineLengthVar - 1) | iter >= addCycles)
                ? Utils.treeReduceAdd(adderInputs)
                : prev);
        }

        // set the flag
        generated = true;
        optimization.popPipeliningFactor();
    }

    public DFEVar output() {
        return out;
    }
}
