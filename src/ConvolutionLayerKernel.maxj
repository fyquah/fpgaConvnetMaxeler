// package nothing;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

public class ConvolutionLayerKernel extends Kernel {
    private final DFEVectorType<DFEVar> outputType;
    private final DFEVectorType<DFEVar> inputType;
    public final ArrayList<Float> bias;
    public ArrayList<ArrayList<float[][]>> convolutionKernels;
    public ArrayList<ConvolutionUnit> convolutionUnits;
    public ArrayList<OneHotDemux> demuxUnits;
    public final Dimension inputDimension;
    public final Dimension outputDimension;
    private final CounterChain masterChain;
    private final int kernelDim, stride, nOutput, loopIterations, foldingFactor;
    private DFEVector<DFEVar> input, output;
    private DFEVar pipelineStage, pipelineLengthVar, row, col;
    private OffsetExpr pipelineLength;
    // number of convolutionalUnits, between 1 <= ff <= inputChannels * outputChannels
    // defines how many convolutionUnits are available to perform all the convolutions
    private final int kernelFoldingFactor; // number of multipliers in every convolutionalUnit, between 1 <= kff <= kernelDim * kernelDim
    private final ArrayList<ConvChannelIndex> convChannelIndices;
    private ArrayList<MultiSourceAccumulator> outputChannelAccumulator;

    public static int calcLoopIterations(int totalConvolutions, int foldingFactor) {
        return Utils.divCeil(totalConvolutions, foldingFactor);
    }

    public OffsetExpr cyclesPerImage() {
        return inputDimension.height() * inputDimension.width() * loopIterations * pipelineLength;
    }

    public InterfaceParam getTicksPerImage(EngineInterface ei, String name) {
        /* NOTE : Remember to change initPipelineLength() too */
        String accName = outputChannelAccumulator[0].getOffsetExprName();
        String convName = convolutionUnits[0].getOffsetExprName();

        InterfaceParam accPipelineLength = ei.getAutoLoopOffset(name, accName);
        InterfaceParam convPipelineLength = ei.getAutoLoopOffset(name, convName);

        InterfaceParam ticksPerImage =
            accPipelineLength + (convPipelineLength * convolutionUnits[0].loopIterations)
            * loopIterations
            * inputDimension.width()
            * inputDimension.height();

        ei.ignoreAutoLoopOffset(name, accName);
        ei.ignoreAutoLoopOffset(name, convName);

        return ticksPerImage;
    }

    protected void initPipelineLength() {
        /* NOTE : Remember to change this for getTicksPerImage too */
        MultiSourceAccumulator acc = outputChannelAccumulator[0];
        pipelineLength = acc.pipelineLength + convolutionUnits[0].cyclesRequired();
        pipelineLengthVar = pipelineLength.getDFEVar(this, dfeUInt(32));
    }

    protected DFEVar pipelineEnd() {
        return pipelineStage.eq(pipelineLengthVar - 1);
    }

    protected DFEVar pipelineStart() {
        return pipelineStage.eq(0);
    }

    protected DFEVar isBorder() {
        DFEVar flag = constant.var(dfeBool(), 0);
        for (int i = 0 ; i < (kernelDim - 1) / 2 ; i++) {
            flag = flag | row.eq(i) | col.eq(i)
                    | row.eq(inputDimension.height() - 1 - i)
                    | col.eq(inputDimension.width() - 1 - i);
        }

        return flag;
    }

    protected List<OffsetExpr> getOffsetParameters() {
        ArrayList<OffsetExpr> ret = new ArrayList<OffsetExpr>();
        ret.add(getAccumulator(0).getOffsetAutoLoop());
        ret.add(convolutionUnits[0].getOffsetAutoLoop());

        return ret;
    }

    protected class ChannelFrequency {
        public final int channel;
        public final int frequency;

        public ChannelFrequency(int argChannel, int argFrequency) {
            channel = argChannel;
            frequency = argFrequency;
        }
    }

    protected class ConvChannelIndex {
        public final int in;
        public final int out;

        public ConvChannelIndex(int o, int i) {
            in = i;
            out = o;
        }
    }

    public ArrayList<ConvChannelIndex> getConvUnitChannelIndices(int convUnitId) {
        ArrayList<ConvChannelIndex> ret = new ArrayList<ConvChannelIndex>();

        for (int i = convUnitId * loopIterations ;
                i < (convUnitId + 1) * loopIterations && i < convChannelIndices.size();
                i++) {
            ret.add(convChannelIndices[i]);
        }

        return ret;
    }

    protected DFEVar[][] toDfeVarKernel(float[][] a) {
        DFEVar[][] ret = new DFEVar[a.length][a[0].length];

        for (int i = 0 ; i < a.length ; i++) {
            for (int j = 0 ; j < a[i].length ; j++) {
                ret[i][j] = constant.var(GlobalConfig.dataType, a[i][j]);
            }
        }

        return ret;
    }

    protected DFEVar toMuxedInput(DFEVar iter, ArrayList<ConvChannelIndex> indices) {
        if (loopIterations == 1) {
            return input[indices[0].in];
        }

        ArrayList<DFEVar> arr = new ArrayList<DFEVar>();

        for (int i = 0 ; i < indices.size() ; i++) {
            arr.add(input[indices[i].in]);
        }


        while (arr.size() < loopIterations) {
            arr.add(constant.var(GlobalConfig.dataType, 0));
        }

        return control.mux(iter, arr.toArray(new DFEVar[arr.size()]));
    }

    protected DFEVar[][] toMuxedKernel(DFEVar iter, ArrayList<ConvChannelIndex> indices) {
        if (indices.size() == 1) {
            return toDfeVarKernel(convolutionKernels
                    .get(indices[0].out)
                    .get(indices[0].in));
        }

        DFEVar[][] ret = new DFEVar[kernelDim][kernelDim];

        for (int r = 0 ; r < kernelDim ; r++) {
            for (int c = 0 ; c < kernelDim ; c++) {
                ArrayList<DFEVar> arr = new ArrayList<DFEVar>();

                for (int i = 0 ; i < indices.size() ; i++) {
                    int out = indices[i].out;
                    int in = indices[i].in;

                    arr.add(
                        constant.var(GlobalConfig.dataType,
                            convolutionKernels
                            .get(out)
                            .get(in)[r][c])
                    );
                }

                // unnecessary, but for completeness
                while (arr.size() < loopIterations) {
                    arr.add(constant.var(GlobalConfig.dataType, 0));
                }

                ret[r][c] = control.mux(iter, arr.toArray(new DFEVar[arr.size()]));
            }
        }

        return ret;
    }

    protected int[] unrollFrequencies(ArrayList<ChannelFrequency> freqs) {
        int totalCount = 0;
        int[] counts;
    
        for (int i = 0 ; i < freqs.size() ; i++) {
            totalCount += freqs[i].frequency;
        }

        if (totalCount < loopIterations) {
            counts = new int[freqs.size() + 1];
            counts[freqs.size()] = loopIterations - totalCount;
        } else {
            counts = new int[freqs.size()];
        }

        for (int i = 0 ; i < freqs.size() ; i++) {
            counts[i] = freqs[i].frequency;
        }

        return counts;
    }

    protected ArrayList<ChannelFrequency> getChannelFrequency(ArrayList<ConvChannelIndex> l) {
        ArrayList<ChannelFrequency> ret = new ArrayList<ChannelFrequency>();

        if (l.size() == 0) {
            return ret;
        }

        ret.add(new ChannelFrequency(l[0].out, 1));

        for (int i = 1 ; i < l.size() ; i++) {
            int tail = ret.size() - 1;
            if (ret[tail].channel != l[i].out) {
                ret.add(new ChannelFrequency(l[i].out, 1));
            } else {
                ret.set(tail, new ChannelFrequency(ret[tail].channel, ret[tail].frequency + 1));
            }
        }

        return ret;
    }

    protected ArrayList<MultiSourceAccumulator> makeOutputChannelAccumulator() {
        ArrayList<MultiSourceAccumulator> ret = new ArrayList<MultiSourceAccumulator>();
        for (int i = 0 ; i < outputDimension.channels() ; i++) {
            MultiSourceAccumulator acc = new MultiSourceAccumulator(
                    this,
                    loopIterations,
                    loopIterations,
                    convolutionUnits[0].cyclesRequired());
            ret.add(acc);
        }
        return ret;
    }

    protected MultiSourceAccumulator getAccumulator(int channel) {
        if (outputChannelAccumulator == null) {
            outputChannelAccumulator = makeOutputChannelAccumulator();
        }

        return outputChannelAccumulator[channel];
    }

    protected ConvolutionLayerKernel(KernelParameters parameters, ConvolutionParameters cp) {
        super(parameters);

        convolutionKernels = new ArrayList<ArrayList<float[][]>>();
        convChannelIndices = new ArrayList<ConvChannelIndex>();
        demuxUnits = new ArrayList<OneHotDemux>();


        // Read definitions from ConvolutionParameters

        inputDimension = cp.inputDim;
        kernelDim = cp.kernelDim;
        nOutput = cp.outputChannels;
        stride = cp.stride;
        foldingFactor = cp.foldingFactor;
        kernelFoldingFactor = cp.kernelFoldingFactor;
        convolutionKernels = cp.getKernels();
        bias = cp.bias;
        //    End parameter extraction

        // derived variables
        outputDimension = new Dimension(
            inputDimension.height() - (kernelDim - 1),
            inputDimension.width() - (kernelDim - 1),
            nOutput);
        inputType = new DFEVectorType<DFEVar>(GlobalConfig.dataType, inputDimension.channels());
        outputType = new DFEVectorType<DFEVar>(GlobalConfig.dataType, nOutput);
        convolutionUnits = new ArrayList<ConvolutionUnit>();
        loopIterations = calcLoopIterations(inputDimension.channels() * outputDimension.channels(), foldingFactor);
        outputChannelAccumulator = null;   // make javac happy

        for (int o = 0 ; o < outputDimension.channels() ; o++) {
            for (int i = 0 ; i < inputDimension.channels() ; i++) {
                convChannelIndices.add(new ConvChannelIndex(o, i));
            }
        }
        // end of derived variables

        // doing the actual maxeler kernel stuff here
        input = inputType.newInstance(this);
        output = outputType.newInstance(this);
        masterChain = control.count.makeCounterChain();
        
        row = Utils.chainCounterOrZero(this, masterChain, inputDimension.height());
        col = Utils.chainCounterOrZero(this, masterChain, inputDimension.width()); 
        DFEVar iter = (loopIterations == 1
                       ? constant.var(dfeUInt(1), 0)
                       : masterChain.addCounter(loopIterations, 1));

        for (int k = 0 ; k < foldingFactor ; k++) {
            ArrayList<ConvChannelIndex> indices = getConvUnitChannelIndices(k);
            DFEVar[][] kernel = toMuxedKernel(iter, indices);
            DFEVar inputChannel = toMuxedInput(iter, indices);
            ArrayList<ChannelFrequency> freqs = getChannelFrequency(indices);
            int[] counts = unrollFrequencies(freqs);

            ConvolutionUnit c = new ConvolutionUnit(
                this,
                inputDimension.height(),
                inputDimension.width(),
                kernel,
                kernelFoldingFactor,
                loopIterations);

            PartitionedDemux demux = new PartitionedDemux(this, counts, c.cyclesRequired());

            c.setInput(inputChannel);
            convolutionUnits.add(c);
            demuxUnits.add(demux);
            demux.input <== c.output();

            for (int i = 0 ; i < freqs.size() ; i++) {
                getAccumulator(freqs[i].channel)
                    .addSource(demux.outputs[i]);
            }
        }

        initPipelineLength();
        pipelineStage = masterChain.addCounter(pipelineLengthVar, 1);

        for (int i = 0 ; i < outputDimension.channels() ; i++) {
            outputChannelAccumulator[i].generate(1.0);
            output[i] <== outputChannelAccumulator[i].output() + bias[i];
        }

        DFEVar tick = control.count.simpleCounter(32);
        debug.simPrintf(
                iter.eq(loopIterations - 1) & pipelineStage.eq(pipelineLengthVar - 1),
                "tick = %d row = %d col = %d\n",
                tick,
                row,
                col);

        // setting the loop counters

        // input and output controls
        DFEVar inputControl = iter.eq(0) & pipelineStart();
        DFEVar outputControl = iter.eq(loopIterations - 1)
                               & ~isBorder()
                               & pipelineEnd();
        input <== io.input("x", inputType, inputControl);
        io.output("y", output, outputType, outputControl);
    }
}
