// package nothing;

import java.util.ArrayList;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;

public class ConvolutionLayerKernel extends Kernel {
    private final DFEVectorType<DFEVar> outputType;
    private final DFEVectorType<DFEVar> inputType;
    public final ArrayList<Float> bias;
    public ArrayList<ArrayList<float[][]>> convolutionKernels;
    public ArrayList<ConvolutionUnit> convolutionUnits;
    public ArrayList<OneHotDemux> demuxUnits;
    public final Dimension inputDimension;
    public final Dimension outputDimension;
    private final CounterChain masterChain;
    private final int kernelDim, stride, nOutput, loopIterations, cyclesRequired;
    private final int foldingFactor, convCyclesRequired;
    private DFEVector<DFEVar> input, output;
    private DFEVar pipelineStage, pipelineLengthVar;
    private OffsetExpr pipelineLength;
    // number of convolutionalUnits, between 1 <= ff <= inputChannels * outputChannels
    // defines how many convolutionUnits are available to perform all the convolutions
    private final int kernelFoldingFactor; // number of multipliers in every convolutionalUnit, between 1 <= kff <= kernelDim * kernelDim
    private final ArrayList<ConvChannelIndex> convChannelIndices;
    private final ArrayList<MultiSourceAccumulator> outputChannelAccumulator;

    public static int calcLoopIterations(int totalConvolutions, int foldingFactor) {
        return Utils.divCeil(totalConvolutions, foldingFactor);
    }

    public int cyclesPerImage() {
        return cyclesRequired * inputDimension.height() * inputDimension.width();
    }

    protected void initPipelineLength() {
        MultiSourceAccumulator acc = outputChannelAccumulator[0];
        pipelineLength = (acc.pipelineLength + acc.convPipelineLength);
        pipelineLengthVar = pipelineLength.getDFEVar(this, dfeUInt(8));
    }

    protected DFEVar pipelineEnd() {
        return pipelineStage.eq(pipelineLengthVar - 1);
    }

    protected DFEVar pipelineStart() {
        return pipelineStage.eq(0);
    }

    protected class ChannelFrequency {
        public final int channel;
        public final int frequency;

        public ChannelFrequency(int argChannel, int argFrequency) {
            channel = argChannel;
            frequency = argFrequency;
        }
    }

    protected class ConvChannelIndex {
        public final int in;
        public final int out;

        public ConvChannelIndex(int o, int i) {
            in = i;
            out = o;
        }
    }

    public ArrayList<ConvChannelIndex> getConvUnitChannelIndices(int convUnitId) {
        ArrayList<ConvChannelIndex> ret = new ArrayList<ConvChannelIndex>();

        for (int i = convUnitId * loopIterations ;
                i < (convUnitId + 1) * loopIterations && i < convChannelIndices.size();
                i++) {
            ret.add(convChannelIndices[i]);
        }

        return ret;
    }

    protected DFEVar[][] toDfeVarKernel(float[][] a) {
        DFEVar[][] ret = new DFEVar[a.length][a[0].length];

        for (int i = 0 ; i < a.length ; i++) {
            for (int j = 0 ; j < a[i].length ; j++) {
                ret[i][j] = constant.var(GlobalConfig.dataType, a[i][j]);
            }
        }

        return ret;
    }

    protected DFEVar toMuxedInput(DFEVar iter, ArrayList<ConvChannelIndex> indices) {
        if (loopIterations == 1) {
            return input[indices[0].in];
        }

        ArrayList<DFEVar> arr = new ArrayList<DFEVar>();

        for (int i = 0 ; i < indices.size() ; i++) {
            arr.add(input[indices[i].in]);
        }


        while (arr.size() < loopIterations) {
            arr.add(constant.var(GlobalConfig.dataType, 0));
        }

        return control.mux(iter, arr.toArray(new DFEVar[arr.size()]));
    }

    protected DFEVar[][] toMuxedKernel(DFEVar iter, ArrayList<ConvChannelIndex> indices) {
        if (indices.size() == 1) {
            return toDfeVarKernel(convolutionKernels
                    .get(indices[0].out)
                    .get(indices[0].in));
        }

        DFEVar[][] ret = new DFEVar[kernelDim][kernelDim];

        for (int r = 0 ; r < kernelDim ; r++) {
            for (int c = 0 ; c < kernelDim ; c++) {
                ArrayList<DFEVar> arr = new ArrayList<DFEVar>();

                for (int i = 0 ; i < indices.size() ; i++) {
                    int out = indices[i].out;
                    int in = indices[i].in;

                    arr.add(
                        constant.var(GlobalConfig.dataType,
                            convolutionKernels
                            .get(out)
                            .get(in)[r][c])
                    );
                }

                // unnecessary, but for completeness
                while (arr.size() < loopIterations) {
                    arr.add(constant.var(GlobalConfig.dataType, 0));
                }

                ret[r][c] = control.mux(iter, arr.toArray(new DFEVar[arr.size()]));
            }
        }

        return ret;
    }

    protected int[] unrollFrequencies(ArrayList<ChannelFrequency> freqs) {
        int totalCount = 0;
        int[] counts;
    
        for (int i = 0 ; i < freqs.size() ; i++) {
            totalCount += freqs[i].frequency;
        }

        if (totalCount < loopIterations) {
            counts = new int[freqs.size() + 1];
            counts[freqs.size()] = loopIterations - totalCount;
        } else {
            counts = new int[freqs.size()];
        }

        for (int i = 0 ; i < freqs.size() ; i++) {
            counts[i] = freqs[i].frequency;
        }

        return counts;
    }

    protected ArrayList<ChannelFrequency> getChannelFrequency(ArrayList<ConvChannelIndex> l) {
        ArrayList<ChannelFrequency> ret = new ArrayList<ChannelFrequency>();

        if (l.size() == 0) {
            return ret;
        }

        ret.add(new ChannelFrequency(l[0].out, 1));

        for (int i = 1 ; i < l.size() ; i++) {
            int tail = ret.size() - 1;
            if (ret[tail].channel != l[i].out) {
                ret.add(new ChannelFrequency(l[i].out, 1));
            } else {
                ret.set(tail, new ChannelFrequency(ret[tail].channel, ret[tail].frequency + 1));
            }
        }

        return ret;
    }

    protected ArrayList<MultiSourceAccumulator> makeOutputChannelAccumulator() {
        ArrayList<MultiSourceAccumulator> ret = new ArrayList<MultiSourceAccumulator>();
        for (int i = 0 ; i < outputDimension.channels() ; i++) {
            MultiSourceAccumulator acc = new MultiSourceAccumulator(
                    this,
                    loopIterations,
                    loopIterations,
                    new OffsetExpr(convCyclesRequired));
            ret.add(acc);
        }
        return ret;
    }

    protected void debugPosition(String name) {
        DFEVar ticksCtr = control.count.simpleCounter(32);
        CounterChain chain2 = control.count.makeCounterChain();
        DFEVar e = chain2.addCounter(10000, 1);
        chain2.addCounter(inputDimension.height(), 1);
        chain2.addCounter(inputDimension.width(), 1);

        if (loopIterations > 1) {
            chain2.addCounter(loopIterations, 1);
        }

        if (convCyclesRequired > 1) {
            chain2.addCounter(convCyclesRequired, 1);
        }

        debug.simPrintf(name + " tick = %d e = %d r = %d , c = %d\n",
                ticksCtr, e,
                convolutionUnits.get(0).row,
                convolutionUnits.get(0).col);
    }

    protected ConvolutionLayerKernel(KernelParameters parameters, ConvolutionParameters cp) {
        super(parameters);

        convolutionKernels = new ArrayList<ArrayList<float[][]>>();
        convChannelIndices = new ArrayList<ConvChannelIndex>();
        demuxUnits = new ArrayList<OneHotDemux>();


        // Read definitions from ConvolutionParameters

        inputDimension = cp.inputDim;
        kernelDim = cp.kernelDim;
        nOutput = cp.outputChannels;
        stride = cp.stride;
        foldingFactor = cp.foldingFactor;
        kernelFoldingFactor = cp.kernelFoldingFactor;
        convolutionKernels = cp.getKernels();
        bias = cp.bias;
        //    End parameter extraction

        // derived variables
        outputDimension = new Dimension(
            inputDimension.height() - (kernelDim - 1),
            inputDimension.width() - (kernelDim - 1),
            nOutput);
        inputType = new DFEVectorType<DFEVar>(GlobalConfig.dataType, inputDimension.channels());
        outputType = new DFEVectorType<DFEVar>(GlobalConfig.dataType, nOutput);
        convolutionUnits = new ArrayList<ConvolutionUnit>();
        loopIterations = calcLoopIterations(inputDimension.channels() * outputDimension.channels(), foldingFactor);
        convCyclesRequired = ConvolutionUnit.calcCyclesRequired(kernelDim, kernelFoldingFactor);
        cyclesRequired = loopIterations * convCyclesRequired;

        for (int o = 0 ; o < outputDimension.channels() ; o++) {
            for (int i = 0 ; i < inputDimension.channels() ; i++) {
                convChannelIndices.add(new ConvChannelIndex(o, i));
            }
        }

        outputChannelAccumulator = makeOutputChannelAccumulator();
        // end of derived variables

        // doing the actual maxeler kernel stuff here
        input = inputType.newInstance(this);
        output = outputType.newInstance(this);
        masterChain = control.count.makeCounterChain();
        DFEVar iter = (loopIterations == 1
                       ? constant.var(dfeUInt(1), 0)
                       : masterChain.addCounter(loopIterations, 1));

        for (int k = 0 ; k < foldingFactor ; k++) {
            ArrayList<ConvChannelIndex> indices = getConvUnitChannelIndices(k);
            DFEVar[][] kernel = toMuxedKernel(iter, indices);
            DFEVar inputChannel = toMuxedInput(iter, indices);
            ArrayList<ChannelFrequency> freqs = getChannelFrequency(indices);
            int[] counts = unrollFrequencies(freqs);

            ConvolutionUnit c = new ConvolutionUnit(
                this,
                inputDimension.height(),
                inputDimension.width(),
                kernel,
                kernelFoldingFactor,
                loopIterations,
                "ConvolutionUnit");

            PartitionedDemux demux = new PartitionedDemux(this, counts, c.cyclesRequired());

            c.setInput(inputChannel);
            convolutionUnits.add(c);
            demuxUnits.add(demux);
            demux.input <== c.output();

            for (int i = 0 ; i < freqs.size() ; i++) {
                outputChannelAccumulator[freqs[i].channel].addSource(demux.outputs[i]);
            }
        }

        initPipelineLength();
        pipelineStage = masterChain.addCounter(pipelineLengthVar, 1);

        for (int i = 0 ; i < outputDimension.channels() ; i++) {
            outputChannelAccumulator[i].generate(0.0);
            output[i] <== outputChannelAccumulator[i].output() + bias[i];
        }

        // debugPosition(parameters.getName());
        // debug.simPrintf(iter.eq(loopIterations - 1) & convIter.eq(convCyclesRequired - 1),
        //         "row = %d col = %d\n",
        //         convolutionUnits[0].row, convolutionUnits[0].col);

        // setting the loop counters

        // input and output controls
        MultiSourceAccumulator acc = outputChannelAccumulator[0];
        DFEVar inputControl = iter.eq(0) & pipelineStart();
        DFEVar outputControl = iter.eq(loopIterations - 1)
                               & ~convolutionUnits.get(0).isBorder()
                               & pipelineEnd();
        input <== io.input("x", inputType, inputControl);
        io.output("y", output, outputType, outputControl);
    }
}
