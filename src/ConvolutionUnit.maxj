// package nothing;

import java.util.ArrayList;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;

// convolves an input stream with a kernel
// TODO(fuyong): STRIDING
public class ConvolutionUnit extends KernelLib {
    DFEVectorType vectorType;
    DFEVar[][] convKernel;
    Kernel kernel;
    int foldingFactor;
    int inputHeight;
    int inputWidth;
    int kernelDim;
    int loopIterations;
    DFEVar input_, output_;
    DFEVar row, col, loopIndex, holdIndex, pipelineIndex;
    DotProductUnit dotProductUnit;
    SlidingWindow slidingWindow;
    OffsetExpr pipelineLength;
    private static int curLoopId = 0;
    public static OffsetExprDefaultDict pipelineLengthCache = new OffsetExprDefaultDict(
            "ConvolutionUnit", 1, 10);

    private static int generateLoopId() {
        return ++curLoopId;
    }

    public static int calcCyclesRequired(int kernelDim, int foldingFactor) {
        return Utils.divCeil(kernelDim * kernelDim, foldingFactor);
    }

    public DFEVar getConvParam(int multiplierNumber) {
        ArrayList<DFEVar> l = new ArrayList<DFEVar>();
        for (int i = multiplierNumber * loopIterations ;
                i < (multiplierNumber + 1) * loopIterations && i < kernelDim * kernelDim;
                i++) {
            l.add(convKernel[i / kernelDim][i % kernelDim]);
        }

        while (l.size() < loopIterations) {
            l.add(constant.var(GlobalConfig.dataType, 0));
        }

        if (l.size() == 1) {
            return l[0];
        } else {
            return control.mux(
                loopIndex,
                l.toArray(new DFEVar[l.size()]));
        }
    }

    public DFEVar getConvInput(int multiplierNumber, DFEVector<DFEVar> input) {
        ArrayList<DFEVar> l = new ArrayList<DFEVar>();
        for (int i = multiplierNumber * loopIterations ;
            i < (multiplierNumber + 1) * loopIterations && i < kernelDim * kernelDim;
            i++) {
            l.add(input[i]);
        }

        while (l.size() < loopIterations) {
            l.add(constant.var(GlobalConfig.dataType, 0));
        }

        if (l.size() == 1) {
            return l[0];
        } else {
            return control.mux(loopIndex, l.toArray(new DFEVar[l.size()]));
        }
    }

    public static OffsetExpr cacheLoopLength;

    public OffsetExpr getOffsetAutoLoop(String loopName) {
        return pipelineLengthCache.get(kernel);
    }

    /* 
     * expects input and argConvKernel to be of the same dimension
     * */
    public ConvolutionUnit(
        Kernel argKernel,
        int argInputHeight, int argInputWidth,
        DFEVar[][] argConvKernel,
        int argFoldingFactor,
        int holdIterations,
        String loopName
    ) {
        super(argKernel);
        // some constants ...
        inputHeight = argInputHeight;
        inputWidth = argInputWidth;
        convKernel = argConvKernel;
        foldingFactor = argFoldingFactor;
        kernelDim = convKernel.length;
        kernel = argKernel;
        vectorType = new DFEVectorType<DFEVar>(
                GlobalConfig.dataType, kernelDim * kernelDim);
        input_ = GlobalConfig.dataType.newInstance(this);

        // Set all counters here
        loopIterations = Utils.divCeil(kernelDim * kernelDim, foldingFactor);
        pipelineLength = getOffsetAutoLoop(loopName);

        CounterChain chain = control.count.makeCounterChain();
        row = chain.addCounter(inputHeight, 1);
        col = chain.addCounter(inputWidth, 1);
        holdIndex = Utils.chainCounterOrZero(kernel, chain, holdIterations);
        loopIndex = Utils.chainCounterOrZero(kernel, chain, loopIterations);
        pipelineIndex = chain.addCounter(
                pipelineLength.getDFEVar(argKernel, dfeUInt(8)),
                1);

        // the computational stuff
        optimization.pushPipeliningFactor(0.0);
        slidingWindow = new SlidingWindow(
            kernel,
            input_,
            inputHeight,
            inputWidth,
            kernelDim,
            pipelineLength * loopIterations * holdIterations);
        dotProductUnit = new DotProductUnit(
            kernel,
            slidingWindow.output(),
            Utils.unrollArray(argConvKernel),
            argFoldingFactor);
        optimization.popPipeliningFactor();

        // output control (we only want to output the valid bits,
        // i.e: ignore the borders)
        output_ = (isBorder()
            ? constant.var(GlobalConfig.dataType, 0)
            : dotProductUnit.output);
    }

    public void debugPrint() {
        DFEVector<DFEVar> v = slidingWindow.output();

        debug.simPrintf("Sliding window : ");
        for (int i = 0 ; i < v.getSize(); i++) {
            debug.simPrintf("%.5f ", v[i]);
        }

        debug.simPrintf("\n");
        debug.simPrintf("multiplierOutput[0]: %.5f\n", dotProductUnit.multiplierOutputs[0]);
        debug.simPrintf("additionResult: %.5f\n", dotProductUnit.additionResult);
        debug.simPrintf("loopIndex = %d\n", loopIndex);
        debug.simPrintf("output() = %.3f\n", dotProductUnit.output);
        debug.simPrintf("row = %d col = %d\n", row, col);
        debug.simPrintf("isBorder() = %d\n", isBorder());
        debug.simPrintf("\n");
    }

    public DFEVar isBorder() {
        DFEVar flag = constant.var(dfeBool(), 0);
        for (int i = 0 ; i < (kernelDim - 1) / 2 ; i++) {
            flag = flag | row.eq(i) | col.eq(i)
                    | row.eq(inputHeight - 1 - i)
                    | col.eq(inputWidth - 1 - i);
        }

        return flag;
    }

    public void setInput(DFEVar argInput) {
        input_ <== argInput;
    }

    public DFEVar isOutputReady() {
        return loopIndex.eq(loopIterations - 1);
    }

    public OffsetExpr cyclesRequired() {
        return loopIterations * pipelineLength;
    }

    public DFEVar index() {
        return loopIndex;
    }

    public DFEVar output() {
        return output_;
    }

    // this class performs the dotProduct functionality
    private class DotProductUnit {
        public DFEVar output, additionResult;
        public ArrayList<DFEVar> multiplierOutputs = new ArrayList<DFEVar>();

        DotProductUnit(Kernel argKernel, DFEVector<DFEVar> input, DFEVar[] a, int foldingFactor) {
            for (int i = 0; i < foldingFactor; i++) {
                DFEVar convParam = getConvParam(i);
                DFEVar convInput = getConvInput(i, input);
                multiplierOutputs.add(convParam * convInput);
            }

            if (loopIterations == 1) {
                additionResult = Utils.treeReduceAdd(multiplierOutputs);
                output = additionResult;

            } else {
                optimization.pushPipeliningFactor(0.0);
                output = GlobalConfig.dataType.newInstance(argKernel);
                ArrayList<DFEVar> x = new ArrayList<DFEVar>();

                for (int i = 0 ; i < multiplierOutputs.size() ; i++) {
                    x.add(multiplierOutputs[i]);
                }

                x.add(loopIndex.eq(0) & pipelineIndex.eq(0)
                        ? constant.var(GlobalConfig.dataType, 0)
                        : stream.offset(output, -pipelineLength));
                additionResult = Utils.treeReduceAdd(x);
                output <== additionResult;
                optimization.popPipeliningFactor();
            }
        }
    }
}

