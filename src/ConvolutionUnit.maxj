// package nothing;

import java.util.ArrayList;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;

// convolves an input stream with a kernel
// TODO : STRIDING
public class ConvolutionUnit extends KernelLib {
    DFEVectorType vectorType;
    DFEVar[][] convKernel;
    Kernel kernel;
    int foldingFactor;
    int inputHeight;
    int inputWidth;
    int kernelDim;
    int loopIterations;
    DFEVar input_, output_, row, col, loopStage, pipelineStage, holdStage;
    DotProductUnit dotProductUnit;
    SlidingWindow slidingWindow;
    OffsetExpr pipelineLength;

    private static int _cur_loop_id = 0;
    public static String generatedLoopId() {
        String ret = "ConvolutionUnit_" + _cur_loop_id + "_pipeline_length";
        _cur_loop_id++;
        return ret;
    }

    public static int calcCyclesRequired(int kernelDim, int foldingFactor) {
        return Utils.divCeil(kernelDim * kernelDim, foldingFactor);
    }

    public DFEVar getConvParam(int multiplierNumber) {
        ArrayList<DFEVar> l = new ArrayList<DFEVar>();
        for (int i = multiplierNumber * loopIterations ;
                i < (multiplierNumber + 1) * loopIterations && i < kernelDim * kernelDim;
                i++) {
            l.add(convKernel[i / kernelDim][i % kernelDim]);
        }

        while (l.size() < loopIterations) {
            l.add(constant.var(GlobalConfig.dataType, 0));
        }

        if (l.size() == 1) {
            return l[0];
        } else {
            return control.mux(
                loopStage,
                l.toArray(new DFEVar[l.size()])
            );
        }
    }

    public DFEVar getConvInput(int multiplierNumber, DFEVector<DFEVar> input) {
        ArrayList<DFEVar> l = new ArrayList<DFEVar>();
        for (int i = multiplierNumber * loopIterations ;
            i < (multiplierNumber + 1) * loopIterations && i < kernelDim * kernelDim;
            i++) {
            l.add(input[i]);
        }

        while (l.size() < loopIterations) {
            l.add(constant.var(GlobalConfig.dataType, 0));
        }

        if (l.size() == 1) {
            return l[0];
        } else {
            return control.mux(loopStage, l.toArray(new DFEVar[l.size()]));
        }
    }

    public ConvolutionUnit(
        // expects input and argConvKernel to be of the same dimension
        // right now, just assume that border pixels are invalid
        Kernel argKernel,
        int argInputHeight, int argInputWidth,
        DFEVar[][] argConvKernel,
        int argFoldingFactor,
        int holdIterations
    ) {
        super(argKernel);
        // some constants ...
        inputHeight = argInputHeight;
        inputWidth = argInputWidth;
        convKernel = argConvKernel;
        foldingFactor = argFoldingFactor;
        kernelDim = convKernel.length;
        kernel = argKernel;
        vectorType = new DFEVectorType<DFEVar>(GlobalConfig.dataType, kernelDim * kernelDim);
        input_ = GlobalConfig.dataType.newInstance(this);
        // pipelineLength = stream.makeOffsetAutoLoop(generatedLoopId());
        pipelineLength = new OffsetExpr(1);

        // Set all the loop-related stuff and counters here
        loopIterations = Utils.divCeil(kernelDim * kernelDim, foldingFactor);
        CounterChain chain = control.count.makeCounterChain();
        row = chain.addCounter(inputHeight, 1);
        col = chain.addCounter(inputWidth, 1);

        if (holdIterations == 1) {
            holdStage = constant.var(dfeUInt(1), 0);
        } else {
            holdStage = chain.addCounter(holdIterations, 1);
        }

        if (loopIterations == 1) {
            loopStage = constant.var(dfeUInt(1), 0);
        } else {
            loopStage = chain.addCounter(loopIterations, 1);
        }

        pipelineStage = chain.addCounter(
                pipelineLength.getDFEVar(argKernel, dfeUInt(8)), 1);

        // the computational stuff
        kernel.optimization.pushPipeliningFactor(0.0);
        slidingWindow = new SlidingWindow(
            kernel,
            input_,
            inputHeight,
            inputWidth,
            kernelDim,
            loopIterations * holdIterations
        );
        dotProductUnit = new DotProductUnit(
            kernel,
            slidingWindow.output(),
            Utils.unrollArray(argConvKernel),
            argFoldingFactor
        );
        kernel.optimization.popPipeliningFactor();

        output_ = isBorder() ? constant.var(GlobalConfig.dataType, 0) : dotProductUnit.output();
    }

    public void debugPrint() {
        DFEVector<DFEVar> v = slidingWindow.output();

        debug.simPrintf("Sliding window : ");
        for (int i = 0 ; i < v.getSize(); i++) {
            debug.simPrintf("%.5f ", v[i]);
        }

        debug.simPrintf("\n");
        debug.simPrintf("multiplierOutput[0]: %.5f\n", dotProductUnit.multiplierOutputs[0]);
        debug.simPrintf("additionResult: %.5f\n", dotProductUnit.additionResult);
        debug.simPrintf("loopStage = %d\n", loopStage);
        debug.simPrintf("output() = %.3f\n", dotProductUnit.output());
        debug.simPrintf("row = %d col = %d\n", row, col);
        debug.simPrintf("isBorder() = %d\n", isBorder());
        debug.simPrintf("\n");
    }

    public DFEVar isBorder() {
        DFEVar flag = constant.var(dfeBool(), 0);
        for (int i = 0 ; i < (kernelDim - 1) / 2 ; i++) {
            flag = flag | row.eq(i) | col.eq(i)
                    | row.eq(inputHeight - 1 - i)
                    | col.eq(inputWidth - 1 - i);
        }

        return flag;
    }

    public void setInput(DFEVar argInput) {
        input_ <== argInput;
    }

    public DFEVar isOutputReady() {
        return loopStage.eq(loopIterations - 1);
    }

    public OffsetExpr cyclesRequired() {
        return loopIterations * pipelineLength;
    }

    public DFEVar index() {
        return loopStage;
    }

    public DFEVar output() {
        return output_;
    }

    // this class performs the dotProduct functionality
    private class DotProductUnit {
        private DFEVar output_;
        public ArrayList<DFEVar> multiplierOutputs = new ArrayList<DFEVar>();
        public DFEVar additionResult;

        DotProductUnit(Kernel argKernel, DFEVector<DFEVar> input, DFEVar[] a, int foldingFactor) {

            for (int i = 0; i < foldingFactor; i++) {
                DFEVar convParam = getConvParam(i);
                DFEVar convInput = getConvInput(i, input);
                multiplierOutputs.add(convParam * convInput);
            }

            if (loopIterations == 1) {
                additionResult = Utils.logarithmAdderTree(
                    multiplierOutputs.toArray(new DFEVar[multiplierOutputs.size()])
                ); output_ = additionResult;

            } else {
                optimization.pushPipeliningFactor(0.0);
                output_ = GlobalConfig.dataType.newInstance(argKernel);
                DFEVar x[] = new DFEVar[multiplierOutputs.size() + 1];
                for (int i = 0 ; i < multiplierOutputs.size() ; i++) {
                    x[i] = multiplierOutputs[i];
                }
                x[multiplierOutputs.size()] = (loopStage.eq(0)
                        ? constant.var(GlobalConfig.dataType, 0)
                        : stream.offset(output_, -pipelineLength));
                additionResult = Utils.logarithmAdderTree(x);
                output_ <== additionResult;
                optimization.popPipeliningFactor();
            }
        }

        public DFEVar output() {
            return output_;
        }
    }
}

