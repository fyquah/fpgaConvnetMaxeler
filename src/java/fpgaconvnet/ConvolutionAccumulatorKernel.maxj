package fpgaconvnet;

import java.util.List;
import java.util.ArrayList;

import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import fpgaconvnet.protos.Parameters.LayerParameter;


public class ConvolutionAccumulatorKernel extends ConvolutionKernelBase {
    private final Memory<DFEVar> biasRom;
    private final LayerParameter layerParams;

    public ConvolutionAccumulatorKernel(KernelParameters kp, LayerParameter params) {
        super(kp, params);

        layerParams = params;
        biasRom = mem.alloc(GlobalConfig.dataType, params.getNumOutputs());
        biasRom.mapToCPU(String.format("bias_layer_%d", params.getLayerId()));

        List<DFEVar> inputVars = new ArrayList<DFEVar>();
        for (int i = 0 ; i < layerParams.getConv().getWorkerFactor() ; i++) {
            inputVars.add(io.input(getInputName(i), GlobalConfig.dataType));
        }
        DFEVar sumVars = Utils.treeReduceAdd(inputVars);

        CounterChain chain = control.count.makeCounterChain();
        DFEVar address = Utils.chainCounterOrZero(this, chain, params.getNumOutputs());
        DFEVar iter = Utils.chainCounterOrZero(this, chain, getSchedulerIterations());
        DFEVar output = GlobalConfig.dataType.newInstance(this);

        if (getSchedulerIterations() == 1) {
            output <== sumVars + biasRom.read(address);
        } else {
            /* TODO(fyquah): Use this if we run at a higher frequency. */
            // DFEParLoop loop = new DFEParLoop(this, "loop");
            // DFEVar result = Utils.treeReduceSum(inputVars) + lp2.feedback;
            // loop.set_input(biasRom.read());
            // loop.set_output(result);
            // io.output(getOutputName(), result, GlobalConfig.dataType, lp2.done);

            DFEVar prevOutput = (iter.eq(0) ?  biasRom.read(address) : stream.offset(output, -1));
            output <== sumVars + prevOutput;
        }
        io.output(getOutputName(), output, GlobalConfig.dataType,
                  iter.eq(getSchedulerIterations() - 1));
        // debugging output
        debug.simPrintf(
                "ConvolutionAccumulatorKernel[layer = %d] address = %d iter = %d output = %.3f\n",
                layerParams.getLayerId(), address, iter, output);
    }

    public String getInputName(int workerId) {
        return "input_" + workerId;
    }

    public String getOutputName() {
        return "output";
    }

    public int cyclesPerImage() {
        return (layerParams.getOutputWidth()
                * layerParams.getOutputHeight()
                * layerParams.getNumOutputs()
                * getSchedulerIterations());
    }
}
