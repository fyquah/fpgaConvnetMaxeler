package fpgaconvnet;

import java.util.List;
import java.util.ArrayList;

import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import fpgaconvnet.protos.Parameters.LayerParameter;


public class ConvolutionAccumulatorKernel extends ConvolutionKernelBase {
    private final Memory<DFEVar> biasRom;
    private final LayerParameter layerParams;

    public ConvolutionAccumulatorKernel(KernelParameters kp, LayerParameter params) {
        super(kp, params);

        layerParams = params;
        biasRom = mem.alloc(GlobalConfig.dataType, params.getNumOutputs());
        biasRom.mapToCPU(String.format("bias_layer_%d", params.getLayerId()));
        final int totalIterations = getCyclesPerChannel();

        DFEVar output = GlobalConfig.dataType.newInstance(this);
        DFEVar inputControlFlag = dfeUInt(1).newInstance(this);
        DFEVar outputControlFlag = dfeUInt(1).newInstance(this);
        List<DFEVar> inputVars = new ArrayList<DFEVar>();
        for (int i = 0 ; i < layerParams.getConv().getWorkerFactor() ; i++) {
            inputVars.add(io.input(getInputName(i), GlobalConfig.dataType, inputControlFlag));
        }
        io.output(getOutputName(), output, GlobalConfig.dataType, outputControlFlag);

        CounterChain chain = control.count.makeCounterChain();
        DFEVar address = Utils.chainCounterOrZero(this, chain, params.getNumOutputs());
        DFEVar iter = Utils.chainCounterOrZero(this, chain, totalIterations);

        DFEVar sumVars = Utils.treeReduceAdd(inputVars);
        if (totalIterations == 1) {
            output <== sumVars + biasRom.read(address);
            inputControlFlag <== constant.var(dfeUInt(1), 1);
            outputControlFlag <== constant.var(dfeUInt(1), 1);
        } else {
            OffsetExpr loopOffsetExpr = stream.makeOffsetAutoLoop(getOffsetExprName());
            DFEVar pipelineLengthVar = loopOffsetExpr.getDFEVar(this,dfeUInt(32));
            DFEVar pipelineStage = chain.addCounter(pipelineLengthVar, 1);

            DFEVar prevOutput = (iter.eq(0)
                    ? biasRom.read(address)
                    : stream.offset(output, -loopOffsetExpr));
            output <== sumVars + prevOutput;
            inputControlFlag <== pipelineStage.eq(0);
            outputControlFlag <==
                    iter.eq(totalIterations - 1) & pipelineStage.eq(pipelineLengthVar - 1);

            debug.simPrintf(
                    "ConvolutionAccumulatorKernel[layer = %d]" +
                    " inputControlFlag = %d outputControlFlag = %d" +
                    " pipelineStage = %d pipelineLengthVar = %d" +
                    " address = %d iter = %d output = %.3f\n",
                    layerParams.getLayerId(),
                    inputControlFlag, outputControlFlag, pipelineStage, pipelineLengthVar,
                    address, iter, output);
        }

        // debug

        // // Pipelined adder - may or may not be better, but this probably will not
        //                      be the bottle neck of the performance, so there is not much point
        //                      pouring too much work into this.
        // DFEParLoop loop = new DFEParLoop(this, "loop");
        // List<DFEVar> inputVars = new ArrayList<DFEVar>();
        // List<DFEVar> transposedInputVars = new ArrayList<DFEVar>();
        // for (int i = 0 ; i < layerParams.getConv().getWorkerFactor() ; i++) {
        //     DFEVar input = io.input(getInputName(i), GlobalConfig.dataType, loop.ndone);
        //     inputVars.add(input);
        //     transposedInputVars.add(transpose(input, abc, loop.pipeline_len));
        // }
        // loop.set_input(biasRom.read(address));

        // DFEVar result = loop.feedback + Utils.treeReduceAdd(transposedInputVars);
        // loop.set_output(result);
        // io.output("result", result, GlobalConfig.dataType, loop.done);
    }

    public String getInputName(int workerId) {
        return "input_" + workerId;
    }

    public String getOutputName() {
        return "output";
    }

    public String getOffsetExprName() {
        return String.format("offset");
    }

    public int getCyclesPerChannel() {
        return getSchedulerIterations() * getConvolutionIterations();

    }

    public int cyclesPerImage() {
        int x = layerParams.getOutputWidth() * layerParams.getOutputHeight()
                * layerParams.getNumOutputs()
                * getCyclesPerChannel();
        System.out.println(String.format(
                    "accum: %d * %d = %d",
                    layerParams.getOutputWidth() * layerParams.getOutputHeight(),
                    getCyclesPerChannel() * layerParams.getNumOutputs(),
                    x));
        return x;
    }
}
