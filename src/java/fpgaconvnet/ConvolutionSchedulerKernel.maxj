package fpgaconvnet;
import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;

import fpgaconvnet.protos.Parameters.LayerParameter;
import fpgaconvnet.protos.Parameters.ConvolutionParameter;

/* 
 * io.input:
 *  x : DFEVector[inputChannels] 
 * io.output:
 *  - y0, y1, y2, ...., y{foldingFactor - 1}
 *  - w0, w1, w2, ...., w{foldingFactor - 1}
 *  Bias will be handled at a later stage of the pipeline.
 *  where y_i and p_i are both inputs to ConvolutionUnit_i
 *        and are of type DFEVector[kerenlDim]
 *        (they are both sliding windows of the input streams
 *         and the convolution parameters respectively.)
 */

public class ConvolutionSchedulerKernel extends ConvolutionKernelBase {
    private final DFEVectorType<DFEVar> inputVectorType, outputVectorType;
    private final SlidingWindow[] slidingWindows;
    private final DFEVector<DFEVar> input;
    private final List<DFEVector<DFEVar>> output_y;
    private final Dimension inputDimension;
    private final int foldingFactor, kernelDim, workerFactor;
    private final DFEVar iter, row, col;
    private final CounterChain masterChain;
    private final int numberOfWeights;
    private final LayerParameter layerParams;

    public ConvolutionSchedulerKernel(KernelParameters kp, LayerParameter argLayerParams) {
        super(kp, argLayerParams);

        layerParams = argLayerParams;
        inputDimension = Utils.layerInputDimension(layerParams);
        kernelDim = layerParams.getConv().getKernelSize();
        workerFactor = layerParams.getConv().getWorkerFactor();
        foldingFactor = layerParams.getConv().getFoldingFactor();
        numberOfWeights = (layerParams.getNumOutputs() * layerParams.getNumInputs() * kernelDim * kernelDim);
        masterChain = control.count.makeCounterChain();
        inputVectorType = new DFEVectorType<DFEVar>(
                GlobalConfig.dataType,
                inputDimension.channels());
        outputVectorType = new DFEVectorType<DFEVar>(
                GlobalConfig.dataType,
                kernelDim * kernelDim);
        input = inputVectorType.newInstance(this);
        output_y = new ArrayList<DFEVector<DFEVar>>();;
        slidingWindows = new SlidingWindow[inputDimension.channels()];
        for (int i = 0 ; i < workerFactor; i++) {
            output_y.add(outputVectorType.newInstance(this));
        }
        for (int i = 0 ; i < inputDimension.channels() ; i++) {
            slidingWindows[i] = new SlidingWindow(
                this,
                input[i],
                inputDimension.height(),
                inputDimension.width(),
                kernelDim,
                new OffsetExpr(getSchedulerIterations()));
        }
        row = Utils.chainCounterOrZero(this, masterChain, inputDimension.height());
        col = Utils.chainCounterOrZero(this, masterChain, inputDimension.width());
        iter = Utils.chainCounterOrZero(this, masterChain, workerFactor);

        input <== io.input(getInputName(), inputVectorType);
        DFEVar outputControlFlag = ~isBorder(row, col);
        for (int workerId = 0 ; workerId < workerFactor ; workerId++) {
            List<Integer> channelList = getSchedulerChannels(workerId);
            io.output(getPixelOutputName(workerId),
                      toMuxedPixel(iter, channelList), outputVectorType, outputControlFlag);
        }

        /* For debugging only. */
        String s_kernel = "[\n";
        for (int i = 0 ; i < kernelDim ; i++) {
            s_kernel += "[";
            for (int j = 0; j < kernelDim ; j++) {
                s_kernel += "%.3f, "; 
            }
            s_kernel += "],\n";
        }
        s_kernel += "]\n";
        for (int i = 0 ; i < workerFactor ; i++) {
            DFEVar[] debugValues = new DFEVar[3 + kernelDim * kernelDim] ;
            debugValues[0] = row;
            debugValues[1] = col;

            for (int j = 0 ; j < kernelDim * kernelDim ; j++) {
                debugValues[3 + kernelDim * kernelDim + j] = output_y[i][j];
            }
            debug.simPrintf("ConvolutionScheduler[layer = " + layerParams.getLayerId() + "] "
                            + "row = %d col = %d worker = " + i + "\n"
                            + "pixel_window = " + s_kernel,
                            debugValues);
        }
    }

    public int cyclesPerImage() {
        return (inputDimension.width() * inputDimension.height() * getSchedulerIterations());
    }

    public String getInputName() {
        return "input";
    }

    public String getPixelOutputName(int convUnitId) {
        return "output_x_" + convUnitId;
    }

    /*
     * This is not used, but as the base class is a ConvolutionKernelBase
     * we will need to implement this.
     */
    public String getOffsetExprName() {
        return "";
    }

    protected DFEVar isBorder(DFEVar row, DFEVar col) {
        DFEVar flag = constant.var(dfeBool(), 0);
        for (int i = 0 ; i < (kernelDim - 1) / 2 ; i++) {
            flag = flag | row.eq(i) | col.eq(i)
                | row.eq(inputDimension.height() - 1 - i)
                | col.eq(inputDimension.width() - 1 - i);
        }

        return flag;
    }

    protected DFEVector<DFEVar> zeroVector(DFEVectorType<DFEVar> type) {
        DFEVector<DFEVar> newVector = type.newInstance(this);

        for (int i = 0 ; i < newVector.getSize() ; i++) {
            newVector[i] <== constant.var(GlobalConfig.dataType, 0);
        }

        return newVector;
    }

    protected DFEVector<DFEVar> toMuxedPixel(DFEVar iter, List<Integer> channels) {

        if (getSchedulerIterations() == 1) {
            Utils.assertTrue(channels.size() == 1);
            return slidingWindows[channels[0]].output;
        }

        List<DFEVector<DFEVar>> arr = new ArrayList<DFEVector<DFEVar>>();
        for (int chan : channels) {
            if (chan != -1) {
                arr.add(slidingWindows[chan].output);
            } else {
                arr.add(zeroVector(outputVectorType));
            }
        }
        return control.mux(iter, arr);
    }
}
