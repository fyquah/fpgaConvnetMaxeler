package fpgaconvnet;

import fpgaconvnet.protos.Parameters.LayerParameter;
import fpgaconvnet.protos.Parameters.ConvolutionParameter;


public class IterationCounter {

    private final LayerParameter layerParams;
    private final ConvolutionParameter convParams;

    public IterationCounter(LayerParameter argLayerParams) {
        layerParams = argLayerParams;
        convParams = layerParams.getConv();
    }

    public int getTotalIterations() {
        return getKernelIterations() * getConvolutionIterations() * getSchedulerIterations();
    }

    public int getRevisitIterations() {
        return Utils.divCeil(
                getWeightIterations(), getConvolutionIterations() * getSchedulerIterations());
    }

    public int getWeightIterations() {
        if (convParams.getBramFactor()
                >= layerParams.getNumInputs() * layerParams.getNumOutputs()) {
            return getConvolutionIterations() * getSchedulerIterations();

        } else {
            return convParams.getBramFactor()
                    / (convParams.getWorkerFactor() * convParams.getConvFoldingFactor());

        }
    }

    /* The number of cycles to perform _one_ convolution */
    public int getKernelIterations() {
        int kernelDim = layerParams.getConv().getKernelSize();
        return Utils.divCeil(kernelDim * kernelDim, layerParams.getConv().getKernelFoldingFactor());
    }

    /* The number of loop iterations required to convolve a input channel's window with all
     * the the filters that concerned it.
     */
    public int getConvolutionIterations() {
        return Utils.divCeil(
                layerParams.getNumOutputs(), layerParams.getConv().getConvFoldingFactor()); 
    }

    /* The number of input channels a worker needs to handle. */
    public int getSchedulerIterations() {
        return Utils.divCeil(layerParams.getNumInputs(), layerParams.getConv().getWorkerFactor());
    }
}
