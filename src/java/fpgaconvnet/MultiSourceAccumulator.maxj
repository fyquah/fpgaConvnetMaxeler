package fpgaconvnet;
// package nothing;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;

/*
 * TODO(fyq14): Is having two arguments (add and hold) really necessary?
 * Smells every much like a YAGNI scenario ...
 */
public class MultiSourceAccumulator extends KernelLib {
    private DFEVar out;
    private Kernel kernel;
    public List<DFEVar> sources;
    public int addCycles, holdCycles;
    public OffsetExpr pipelineLength;
    public DFEVar iter, pipelineIndex, pipelineLengthVar;
    /* offsetdefaultdict ensures that every kernel has only one offsetexpr, which
     * should be perfectly sensible since there is only one output per kernel */
    public static OffsetExprDefaultDict pipelineLengthCache = new OffsetExprDefaultDict(
            "MultiSourceAccumulator", 1, 10);

    public OffsetExpr getOffsetAutoLoop() {
        return pipelineLengthCache.get(kernel);
    }

    public String getOffsetExprName() {
        return pipelineLengthCache.getOffsetExprName(kernel);
    }

    public MultiSourceAccumulator (
            Kernel argKernel,
            int argAddCycles,
            int argHoldCycles) {
        super(argKernel);
        kernel = argKernel;
        addCycles = argAddCycles;
        holdCycles = argHoldCycles;
        sources = new ArrayList<DFEVar>();
        out = GlobalConfig.dataType.newInstance(this);
        pipelineLength = getOffsetAutoLoop();
        pipelineLengthVar = pipelineLength.getDFEVar(this, dfeUInt(32));

        CounterChain chain = control.count.makeCounterChain();
        iter = Utils.chainCounterOrZero(argKernel, chain, argHoldCycles);
        pipelineIndex = chain.addCounter(pipelineLengthVar, 1);

        if (argAddCycles < argHoldCycles) {
            System.out.println("addCycles cannot be < holdcycles!");
            System.exit(-1);
        }
    }

    public void debug(DFEVar debugFlag) {
        debug.simPrintf(debugFlag, "======== start debug ========\n");
        debug.simPrintf(debugFlag, "pipelineIndex = %d\n", pipelineIndex);
        debug.simPrintf(debugFlag, "iter = %d\n", iter);
        debug.simPrintf(debugFlag, "pipelineLength = %d\n", pipelineLengthVar);
        debug.simPrintf(debugFlag, "======== end debug ========\n");
    }

    public void addSource(DFEVar x) {
        sources.add(x);
    }

    public void generate() {
        generate(1.0);
    }

    public void generate(double pipeliningFactor) {
        // Compute previous (either 0 or output[-1])
        optimization.pushPipeliningFactor(pipeliningFactor);
        OffsetExpr offset = -(pipelineLength);
        DFEVar prev = (iter.eq(0)
                ? constant.var(GlobalConfig.dataType, 0)
                : stream.offset(out, offset));

        // compute the new input
        List<DFEVar> adderInputs = Utils.dupList(sources, prev);

        // Decide whether to show previous / updated input
        if (addCycles == holdCycles) {
            out <== (pipelineIndex.eq(pipelineLengthVar - 1)
                     ? Utils.treeReduceAdd(adderInputs)
                     : prev);
        } else {
            out <== ((pipelineIndex.eq(pipelineLengthVar - 1) | iter >= addCycles)
                ? Utils.treeReduceAdd(adderInputs)
                : prev);
        }

        // set the flag
        optimization.popPipeliningFactor();
    }

    public DFEVar output() {
        return out;
    }
}
