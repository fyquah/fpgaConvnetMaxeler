package fpgaconvnet.kernels;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import fpgaconvnet.GlobalConfig;
import fpgaconvnet.Utils;
import fpgaconvnet.protos.Parameters.LayerParameter;
import fpgaconvnet.protos.Parameters.ConvolutionParameter;
import fpgaconvnet.lib.CpuInitWeightsCounter;
import fpgaconvnet.lib.LookAheadCounter;


public class ConvolutionUnitKernel extends ConvolutionKernelBase {

    public enum WeightsLoadStrategy {
        INIT_FROM_CPU,
        STREAM_FROM_LMEM,
        WITH_CACHE,
    };

    private final int kernelDim;
    private final int weightsRefreshPeriod; /* The period where hew weights has to be fetched
                                               from off-chip memory. */
    private final DFEVectorType<DFEVar> inputVectorType;
    private final DFEVectorType<DFEVar> outputVectorType;
    private final LayerParameter layerParams;
    private final ConvolutionParameter convParams;

    private DFEVector<DFEVar> cpuWeightsInput = null;
    private CpuInitWeightsCounter cpuInitWeightsCounter = null;
    private LookAheadCounter lookAheadCounter = null;

    public ConvolutionUnitKernel(KernelParameters kp, LayerParameter params) {
        super(kp, params);
        convParams = params.getConv();
        layerParams = params;
        kernelDim = params.getConv().getKernelSize();
        weightsRefreshPeriod = getKernelIterations()
                * convParams.getBramFactor()
                / (convParams.getWorkerFactor() * convParams.getConvFoldingFactor());

        inputVectorType = new DFEVectorType<DFEVar>(GlobalConfig.dataType, kernelDim * kernelDim);
        outputVectorType = new DFEVectorType<DFEVar>(
                GlobalConfig.dataType, layerParams.getConv().getConvFoldingFactor());

        final int convFoldingFactor = layerParams.getConv().getConvFoldingFactor();
        final int kernelFoldingFactor = layerParams.getConv().getKernelFoldingFactor();
        final int totalAddressCount =
                (convParams.getBramFactor()
                 / (convParams.getWorkerFactor() * convParams.getConvFoldingFactor()))
                * getKernelIterations();

        DFEVar address;
        if (totalAddressCount <= 1) {
            address = constant.var(dfeBool(), 0);

        } else {
            address = control.count.simpleCounter(
                   Utils.ceilLog2(totalAddressCount), totalAddressCount);

        }

        DFEVar inputControlFlag = null;
        DFEVar outputControlFlag = null;

        switch (getWeightsLoadStrategy()) {
        case INIT_FROM_CPU:
            cpuInitWeightsCounter = new CpuInitWeightsCounter(this, layerParams);
            inputControlFlag = cpuInitWeightsCounter.getInputControlFlag();
            outputControlFlag = cpuInitWeightsCounter.getOutputControlFlag();

        case STREAM_FROM_LMEM:
            break;

        case WITH_CACHE:
            lookAheadCounter = new LookAheadCounter(this, layerParams);
            inputControlFlag = lookAheadCounter.getInputControlFlag();
            outputControlFlag = lookAheadCounter.getOutputControlFlag();
            break;

        }

        for (int workerId = 0 ; workerId < params.getConv().getWorkerFactor() ; workerId++) {

            DFEVector<DFEVar> inputWindow = io.input(getInputName(workerId),
                                                     inputVectorType,
                                                     inputControlFlag);

            DFEVector<DFEVar> output = outputVectorType.newInstance(this);
            final DFEVar[] pixelVars = new DFEVar[layerParams.getConv().getKernelFoldingFactor()];
            final DFEVar[][] weightVars = new DFEVar[convFoldingFactor][kernelFoldingFactor];

            for (int multId = 0; multId < layerParams.getConv().getKernelFoldingFactor(); multId++) {
                pixelVars[multId] = getConvPixel(multId, inputWindow);
            }

            for (int convUnitIndex = 0; convUnitIndex < convFoldingFactor; convUnitIndex++) {
                DFEVar convUnitOutput = constant.var(GlobalConfig.dataType, 0.0);

                for (int multId = 0; multId < kernelFoldingFactor; multId++) {

                    /* Determine the weight fetching strategy based on the foldingFactors. */
                    weightVars[convUnitIndex][multId] = getConvWeights(
                            workerId, convUnitIndex, multId, address);

                    convUnitOutput = convUnitOutput
                            + pixelVars[multId] * weightVars[convUnitIndex][multId];

                }
                output[convUnitIndex] <== convUnitOutput;
            }

            io.output(getOutputName(workerId), output, outputVectorType, outputControlFlag); }
    }

    public int stallInitCycles() {
        return initCycles() - realInitCycles();
    }

    public int realInitCycles() {
        return layerParams.getConv().getWorkerFactor()
                * layerParams.getConv().getConvFoldingFactor()
                * getSchedulerIterations()
                * getConvolutionIterations()
                * getKernelIterations();
    }

    public int initCycles() {
        /* Return different values based on caching strategy. */
        int multipleBase =
                ((int) Utils.lcm(4, layerParams.getConv().getKernelFoldingFactor()))
                / layerParams.getConv().getKernelFoldingFactor();
        return Utils.divCeil(realInitCycles(), multipleBase) * multipleBase;
    }

    public int initStreamSize() {
        // size of every weight input Vector.
        return initCycles() * layerParams.getConv().getKernelFoldingFactor();
    }

    public int cyclesPerImage() {
        int totalOutputPixels = layerParams.getOutputHeight() * layerParams.getOutputWidth();
        int cyclesPerPixel = getSchedulerIterations()
                * getConvolutionIterations()
                * getKernelIterations();
        return totalOutputPixels * cyclesPerPixel;
    }

    public String getInputName(int workerId) {
        return "input_" + workerId;
    }

    public String getCpuWeightsInputName() {
        return "weights_input";
    }

    public String getLMemWeightName(int worker, int conv, int mult) {
        return String.format("weight_lmem_%d_%d_%d", worker, conv, mult);
    }

    public List<String> getLMemWeightsNames() {
        List<String> ret = new ArrayList<String>();

        for (int worker = 0; worker < convParams.getWorkerFactor() ; worker++) {
            for (int conv = 0 ; conv < convParams.getConvFoldingFactor() ; conv++) {
                for (int mult = 0 ; mult < convParams.getKernelFoldingFactor(); mult++) {
                    ret.add(getLMemWeightName(worker, conv, mult));
                }
            }
        }

        return ret;
    }

    public String getOutputName(int workerId) {
        return "output_" + workerId;
    }

    public WeightsLoadStrategy getWeightsLoadStrategy() {
        if (weightsRefreshPeriod == getTotalIterations()) {
            return WeightsLoadStrategy.INIT_FROM_CPU;

        } else if (convParams.getLookAhead() == 1) {
            return WeightsLoadStrategy.STREAM_FROM_LMEM;

        } else {
            return WeightsLoadStrategy.WITH_CACHE;

        }
    }

    private DFEVar getConvPixel(
            int multiplierNumber, DFEVector<DFEVar> inputWindow) {
        final DFEVar[] pixelChoices = new DFEVar[getKernelIterations()];
        for (int i = 0; i < getKernelIterations() ; i++) {
            int idx = multiplierNumber + i * layerParams.getConv().getKernelFoldingFactor();

            if (idx < inputWindow.getSize()) {
                pixelChoices[i] = inputWindow[idx];
            } else {
                pixelChoices[i] = constant.var(GlobalConfig.dataType, 0);
            }
        }

        switch (getWeightsLoadStrategy()) {
        case INIT_FROM_CPU:
            if (getKernelIterations() == 1) {
                return inputWindow[multiplierNumber];
            }
            return control.mux(cpuInitWeightsCounter.getKernelIter(), pixelChoices);

        case STREAM_FROM_LMEM:
            return null;

        case WITH_CACHE:
            Memory<DFEVar> pixelsMem = mem.alloc(GlobalConfig.dataType, getKernelIterations());
            DFEVar pixel = control.mux(lookAheadCounter.getKernelIter(), pixelChoices);
            pixelsMem.write(
                    lookAheadCounter.getKernelIter(),
                    pixel,
                    lookAheadCounter.getPixelWriteEnable());
            return (lookAheadCounter.getPixelWriteEnable()
                    ? pixel
                    : pixelsMem.read(lookAheadCounter.getKernelIter()));
        }

        /* Makes compiler happy. */
        return null;
    }

    private DFEVector<DFEVar> getCpuWeightsInput() {
        if (cpuWeightsInput != null) {
            return cpuWeightsInput;

        } else if (getWeightsLoadStrategy() == WeightsLoadStrategy.INIT_FROM_CPU) {
            DFEVectorType<DFEVar> weightInputVectorType = new DFEVectorType<DFEVar>(
                    GlobalConfig.dataType, layerParams.getConv().getKernelFoldingFactor());
            DFEVectorType<DFEVar> rawWeightInputVectorType = new DFEVectorType<DFEVar>(
                    GlobalConfig.cpuType, layerParams.getConv().getKernelFoldingFactor());
            DFEVector<DFEVar> rawWeightsInputs = io.input(
                    getCpuWeightsInputName(),
                    rawWeightInputVectorType,
                    cpuInitWeightsCounter.getWeightsInputFlag());
            cpuWeightsInput = rawWeightsInputs.cast(weightInputVectorType);
            return cpuWeightsInput;

        } else {
            throw new RuntimeException("getCpuWeightsInput() should only be used from a"
                    + " host-initialized weights net.");

        }

    }

    public DFEVar getConvWeights(
            int workerId, int convUnitIndex, int multId, DFEVar address) {
        Memory<DFEVar> filtersRom = null;
        final int totalAddressCount =
                (convParams.getBramFactor()
                 / (convParams.getWorkerFactor() * convParams.getConvFoldingFactor()))
                * getKernelIterations();

        switch (getWeightsLoadStrategy()) {
        case INIT_FROM_CPU:
            filtersRom = mem.alloc(
                    GlobalConfig.dataType, totalAddressCount);
            filtersRom.write(
                    address,
                    getCpuWeightsInput()[multId],
                    cpuInitWeightsCounter.getWriteEnable(workerId, convUnitIndex));
            return filtersRom.read(address);

        case STREAM_FROM_LMEM:
            return null;

        case WITH_CACHE:
            filtersRom = mem.alloc(GlobalConfig.dataType, totalAddressCount);
            DFEVar weightInput = io.input(
                    getLMemWeightName(workerId, convUnitIndex, multId),
                    GlobalConfig.dataType,
                    lookAheadCounter.getWeightsInputFlag());
            filtersRom.write(
                    lookAheadCounter.getAddress(),
                    weightInput,
                    lookAheadCounter.getWriteEnable());
            return (lookAheadCounter.getWriteEnable()
                    ? weightInput 
                    : filtersRom.read(lookAheadCounter.getAddress()));

        }

        /* Makes compiler happy. */
        return null;
    }

    public int lmemStreamSizePerImage() {
        int totalPixels =
                layerParams.getOutputHeight() * layerParams.getOutputWidth()
                / layerParams.getConv().getLookAhead();
        return Utils.divCeil(getTotalIterations(), weightsRefreshPeriod) * totalPixels;
    }
}
