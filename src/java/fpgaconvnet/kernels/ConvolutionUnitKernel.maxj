package fpgaconvnet.kernels;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;

import fpgaconvnet.GlobalConfig;
import fpgaconvnet.Utils;
import fpgaconvnet.protos.Parameters.LayerParameter;
import fpgaconvnet.protos.Parameters.ConvolutionParameter;


public class ConvolutionUnitKernel extends ConvolutionKernelBase {

    public enum WeightsLoadStrategy {
        INIT_FROM_CPU,
        STREAM_FROM_LMEM,
        WITH_CACHE,
    };

    private final int kernelDim;
    private final int weightsRefreshPeriod; /* The period where hew weights has to be fetched
                                               from off-chip memory. */
    private final DFEVectorType<DFEVar> rawWeightInputVectorType;
    private final DFEVectorType<DFEVar> weightInputVectorType;
    private final DFEVectorType<DFEVar> inputVectorType;
    private final DFEVectorType<DFEVar> outputVectorType;
    private final LayerParameter layerParams;
    private final ConvolutionParameter convParams;

    private final DFEVar cpuWeightsInput = null;
    private final CpuInitWeightsCounter cpuInitWeightsCounter = null;
    private final LookAheadCounter lookAheadCounter = null;

    public ConvolutionUnitKernel(KernelParameters kp, LayerParameter params) {
        super(kp, params);
        convParams = params.getConv();
        layerParams = params;
        kernelDim = params.getConv().getKernelSize();
        final int weightsInputSize =
                params.getConv().getBramFactor()
                / (convParams.getWorkerFactor() * convParams.getConvFoldingFactor())
                * params.getConv().getKernelSize()
                * params.getConv().getKernelSize();
        weightsRefreshPeriod = getKernelIterations()
                * convParams.getBramFactor()
                / (convParams.getWorkerFactor() * convParams.getConvFoldingFactor());

        inputVectorType = new DFEVectorType<DFEVar>(GlobalConfig.dataType, kernelDim * kernelDim);
        outputVectorType = new DFEVectorType<DFEVar>(
                GlobalConfig.dataType, layerParams.getConv().getConvFoldingFactor());

        final int convFoldingFactor = layerParams.getConv().getConvFoldingFactor();
        final int kernelFoldingFactor = layerParams.getConv().getKernelFoldingFactor();
        final int totalAddressCount =
                (convParams.getBramFactor()
                 / (convParams.getWorkerFactor() * convParams.getConvFoldingFactor()))
                * getKernelIterations();

        // TODO(fyq14):  Handle fully unrolled case.
        DFEVar address = control.count.simpleCounter(
                Utils.ceilLog2(totalAddressCount), totalAddressCount);

        DFEVar inputControlFlag = null;
        DFEVar outputControlFlag = null;

        switch (getWeightsLoadStrategy()) {
        case INIT_CPU:
            cpuInitWeightsCounter = new CpuInitWeightsCounter(this, layerParams);
            inputControlFlag = cpuInitWeightsCounter.getInputControlFlag();
            outputControlFlag = cpuInitWeightsCounter.getOutputControlFlag();

        case STREAM_FROM_LMEM:
            break;

        case WITH_CACHE:
            lookAheadCounter = new LookAheadCounter(this, layerParams);
            inputControlFlag = lookAheadCounter.getInputControlFlag();
            outputControlFlag = lookAheadCounter.getOutputControlFlag();
            break;

        }

        for (int workerId = 0 ; workerId < params.getConv().getWorkerFactor() ; workerId++) {

            DFEVector<DFEVar> inputWindow = io.input(getInputName(workerId),
                                                     inputVectorType,
                                                     inputControlFlag);

            DFEVector<DFEVar> output = outputVectorType.newInstance(this);
            final DFEVar[] pixelVars = new DFEVar[layerParams.getConv().getKernelFoldingFactor()];
            final DFEVar[][] weightVars = new DFEVar[convFoldingFactor][kernelFoldingFactor];

            for (int multId = 0; multId < layerParams.getConv().getKernelFoldingFactor(); multId++) {
                pixelVars[multId] = getConvPixel(multId, inputWindow);
            }

            for (int convUnitIndex = 0; convUnitIndex < convFoldingFactor; convUnitIndex++) {
                DFEVar convUnitOutput = constant.var(GlobalConfig.dataType, 0.0);

                for (int multId = 0; multId < kernelFoldingFactor; multId++) {

                    /* Determine the weight fetching strategy based on the foldingFactors. */
                    weightVars[convUnitIndex][multId] = getConvWeight();

                    convUnitOutput = convUnitOutput
                            + pixelVars[multId] * weightVars[convUnitIndex][multId];

                }
                output[convUnitIndex] <== convUnitOutput;
            }

            io.output(getOutputName(workerId), output, outputVectorType, outputControlFlag); }
    }

    public int stallInitCycles() {
        return initCycles() - realInitCycles();
    }

    public int realInitCycles() {
        return layerParams.getConv().getWorkerFactor()
                * layerParams.getConv().getConvFoldingFactor()
                * getSchedulerIterations()
                * getConvolutionIterations()
                * getKernelIterations();
    }

    public int initCycles() {
        int multipleBase =
                ((int) Utils.lcm(4, layerParams.getConv().getKernelFoldingFactor()))
                / layerParams.getConv().getKernelFoldingFactor();
        return Utils.divCeil(realInitCycles(), multipleBase) * multipleBase;
    }

    public int initStreamSize() {
        // size of every weight input Vector.
        return initCycles() * layerParams.getConv().getKernelFoldingFactor();
    }

    public int cyclesPerImage() {
        int totalOutputPixels = layerParams.getOutputHeight() * layerParams.getOutputWidth();
        int cyclesPerPixel = getSchedulerIterations()
                * getConvolutionIterations()
                * getKernelIterations();
        return totalOutputPixels * cyclesPerPixel;
    }

    public String getInputName(int workerId) {
        return "input_" + workerId;
    }

    public String getCpuWeightsInputName() {
        return "weights_input";
    }

    public String getLMemWeightName(int worker, int conv, int mult) {
        return String.format("weight_lmem_%d_%d_%d", worker, conv, mult);
    }

    public List<String> getLMemWeightsNames() {
        List<String> ret = new ArrayList<String>();

        for (int worker = 0; worker < convParams.getWorkerFactor() ; worker++) {
            for (int conv = 0 ; conv < convParams.getConvFoldingFactor() ; conv++) {
                for (int mult = 0 ; mult < convParams.getKernelFoldingFactor(); mult++) {
                    ret.add(getLMemWeightName(worker, conv, mult));
                }
            }
        }

        return ret;
    }

    public String getOutputName(int workerId) {
        return "output_" + workerId;
    }

    public WeightsLoadStrategy getWeightsLoadStrategy() {
        if (weightsRefreshPeriod == getTotalIterations()) {
            return INIT_FROM_CPU;

        } else if (convParams.getLookAhead() == 1) {
            return STREAM_FROM_LMEM;

        } else {
            return WITH_CACHE;

        }
    }

    private DFEVar getConvPixel(
            int multiplierNumber, DFEVector<DFEVar> inputWindow) {
        final DFEVar[] pixelChoices = new DFEVar[getKernelIterations()];
        for (int i = 0; i < getKernelIterations() ; i++) {
            int idx = multiplierNumber + i * layerParams.getConv().getKernelFoldingFactor();

            if (idx < inputWindow.getSize()) {
                pixelChoices[i] = inputWindow[idx];
            } else {
                pixelChoices[i] = constant.var(GlobalConfig.dataType, 0);
            }
        }

        switch (getWeightsLoadStrategy()) {
        case INIT_CPU:
            if (getKernelIterations() == 1) {
                return inputWindow[multiplierNumber];
            }
            return control.mux(cpuInitWeightsCounter.getKernelIter(), pixelChoices);

        case STREAM_FROM_LMEM:
            return null;

        case WITH_CACHE:
            Memory<DFEVar> pixelsMem = mem.alloc(GlobalConfig.dataType, getKernelIterations());
            DFEVar pixel = control.mux(cpuInitWeightsCounter.getKernelIter(), pixelChoices);
            pixelsMem.write(
                    lookAheadCounter.getKernelIter(),
                    pixel,
                    lookAheadCounter.getPixelWriteEnable());
            return (lookAheadCounter.getPixelWriteEnable()
                    ? pixel : pixelsMem.read(lookAheadCounter.getKernelIter(), pixel))
        }
    }

    private DFEVector<DFEVar> getCpuWeightsInput() {
        if (cpuWeightsInput != null) {
            return cpuWeightsInput;

        } else if (getWeightsLoadStrategy() == INIT_FROM_CPU) {
            weightInputVectorType = new DFEVectorType<DFEVar>(
                    GlobalConfig.dataType, params.getConv().getKernelFoldingFactor());
            rawWeightInputVectorType = new DFEVectorType<DFEVar>(
                    GlobalConfig.cpuType, layerParms.getConv().getKernelFoldingFactor());
            rawWeightsInputs = io.input(
                    getCpuWeightsInputName(), rawWeightInputVectorType, isInitializingWeights);
            cpuWeightsInput = rawWeightsInputs.cast(weightInputVectorType);
            return cpuWeightsInput;

        } else {
            throw new RuntimeException("getCpuWeightsInput() should only be used from a"
                    + " host-initialized weights net.");

        }

    }

    public DFEVar getConvWeights() {
        switch (getWeightsLoadStrategy()) {
        case INIT_CPU:
            Memory<DFEVar> filtersRom = mem.alloc(
                    GlobalConfig.dataType, totalAddressCount);
            filtersRom.write(
                    address,
                    getCpuWeightsInput(multId),
                    cpuInitWeightsCounter.getWriteEnable(workerId, convUnitIndex));
            return filtersRom.read(address);

        case STREAM_FROM_LMEM:
            return null;

        case WITH_CACHE:
            Memory<DFEVar> filtersRom = mem.alloc(GlobalConfig.dataType, totalAddressCount);
            weightsInputs = io.input(
                    getLMemWeightName(workerId, convUnitIndex, multId),
                    GlobalConfig.dataType,
                    lookAheadCounter.getWeightsInputFlag());
            filterRom.write(
                    lookAheadCounter.getWriteAddress(),
                    weightInput,
                    lookAheadCounter.writeEnable());
            return (lookAheadCounter.writeEnable()
                    ? weightInput 
                    : filterRom.read(lookAheadCounter.getReadAddress()))

        }
    }
}
