package fpgaconvnet.kernels;

import java.util.ArrayList;
import java.util.List;
import java.lang.RuntimeException;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import fpgaconvnet.GlobalConfig;
import fpgaconvnet.Utils;
import fpgaconvnet.protos.Parameters.LayerParameter;
import fpgaconvnet.protos.Parameters.ConvolutionParameter;
import fpgaconvnet.lib.CpuInitWeightsCounter;
import fpgaconvnet.lib.LookAheadCounter;


public class ConvolutionUnitKernel extends ConvolutionKernelBase {

    public enum WeightsLoadStrategy {
        INIT_FROM_CPU,
        STREAM_FROM_LMEM,
        WITH_CACHE,
    };

    private final int kernelDim;
    private final DFEVectorType<DFEVar> inputVectorType;
    private final DFEVectorType<DFEVar> outputVectorType;
    private final LayerParameter layerParams;
    private final ConvolutionParameter convParams;
    private final int convFoldingFactor;
    private final int kernelFoldingFactor;
    private final int totalAddressCount;

    private DFEVector<DFEVar> lmemWeightsInput = null;
    private DFEVector<DFEVar> cpuWeightsInput = null;
    private CpuInitWeightsCounter cpuInitWeightsCounter = null;
    private LookAheadCounter lookAheadCounter = null;

    public ConvolutionUnitKernel(KernelParameters kp, LayerParameter params) {
        super(kp, params);
        convParams = params.getConv();
        layerParams = params;
        kernelDim = params.getConv().getKernelSize();

        inputVectorType = new DFEVectorType<DFEVar>(GlobalConfig.dataType, kernelDim * kernelDim);
        outputVectorType = new DFEVectorType<DFEVar>(
                GlobalConfig.dataType, layerParams.getConv().getConvFoldingFactor());

        convFoldingFactor = layerParams.getConv().getConvFoldingFactor();
        kernelFoldingFactor = layerParams.getConv().getKernelFoldingFactor();
        totalAddressCount = iterCounter.getWeightIterations() * getKernelIterations();

        DFEVar address;
        if (totalAddressCount <= 1) {
            address = constant.var(dfeBool(), 0);

        } else {
            address = control.count.simpleCounter(
                   Utils.ceilLog2(totalAddressCount), totalAddressCount);

        }

        DFEVar inputControlFlag = null;
        DFEVar outputControlFlag = null;

        switch (getWeightsLoadStrategy()) {
        case INIT_FROM_CPU:
            cpuInitWeightsCounter = new CpuInitWeightsCounter(this, layerParams);
            inputControlFlag = cpuInitWeightsCounter.getInputControlFlag();
            outputControlFlag = cpuInitWeightsCounter.getOutputControlFlag();
            break;

        case STREAM_FROM_LMEM:
            throw new RuntimeException("STREAM_FROM_LMEM not implemented");

        case WITH_CACHE:
            lookAheadCounter = new LookAheadCounter(this, layerParams);
            inputControlFlag = lookAheadCounter.getInputControlFlag();
            outputControlFlag = lookAheadCounter.getOutputControlFlag();
            break;

        }

        for (int workerId = 0 ; workerId < params.getConv().getWorkerFactor() ; workerId++) {

            DFEVector<DFEVar> inputWindow = io.input(getInputName(workerId),
                                                     inputVectorType,
                                                     inputControlFlag);

            DFEVector<DFEVar> output = outputVectorType.newInstance(this);
            final DFEVar[] pixelVars = new DFEVar[layerParams.getConv().getKernelFoldingFactor()];
            final DFEVar[][] weightVars = new DFEVar[convFoldingFactor][kernelFoldingFactor];

            for (int multId = 0; multId < layerParams.getConv().getKernelFoldingFactor(); multId++) {
                pixelVars[multId] = getConvPixel(multId, inputWindow);
            }

            for (int convUnitIndex = 0; convUnitIndex < convFoldingFactor; convUnitIndex++) {
                DFEVar convUnitOutput = constant.var(GlobalConfig.dataType, 0.0);

                for (int multId = 0; multId < kernelFoldingFactor; multId++) {

                    /* Determine the weight fetching strategy based on the foldingFactors. */
                    weightVars[convUnitIndex][multId] = getConvWeights(
                            workerId, convUnitIndex, multId, address);

                    convUnitOutput = convUnitOutput
                            + pixelVars[multId] * weightVars[convUnitIndex][multId];

                }
                output[convUnitIndex] <== convUnitOutput;
            }

            io.output(getOutputName(workerId), output, outputVectorType, outputControlFlag);
        }
    }

    /* initCycles used only in CPU initialization. */
    public int stallInitCycles() {
        return initCycles() - realInitCycles();
    }

    public int realInitCycles() {
        return layerParams.getConv().getWorkerFactor()
                * layerParams.getConv().getConvFoldingFactor()
                * getSchedulerIterations()
                * getConvolutionIterations()
                * getKernelIterations();
    }

    public int initCycles() {
        /* Return different values based on caching strategy. */
        int multipleBase =
                ((int) Utils.lcm(4, layerParams.getConv().getKernelFoldingFactor()))
                / layerParams.getConv().getKernelFoldingFactor();
        return Utils.divCeil(realInitCycles(), multipleBase) * multipleBase;
    }

    public int initStreamSize() {
        // size of every weight input Vector.
        return initCycles() * layerParams.getConv().getKernelFoldingFactor();
    }

    public int cyclesPerImage() {
        int totalOutputPixels = layerParams.getOutputHeight() * layerParams.getOutputWidth();
        int cyclesPerPixel = getSchedulerIterations()
                * getConvolutionIterations()
                * getKernelIterations();
        return totalOutputPixels * cyclesPerPixel;
    }

    public String getInputName(int workerId) {
        return "input_" + workerId;
    }

    public String getCpuWeightsInputName() {
        return "weights_input";
    }

    public String getLMemWeightName() {
        return "weight_lmem";
    }

    public String getOutputName(int workerId) {
        return "output_" + workerId;
    }

    public WeightsLoadStrategy getWeightsLoadStrategy() {
        if (convParams.getBramFactor() >= layerParams.getNumInputs() * layerParams.getNumOutputs()) {
            return WeightsLoadStrategy.INIT_FROM_CPU;

        } else if (convParams.getLookAhead() == 1) {
            return WeightsLoadStrategy.STREAM_FROM_LMEM;

        } else {
            return WeightsLoadStrategy.WITH_CACHE;

        }
    }

    private DFEVar getConvPixel(
            int multiplierNumber, DFEVector<DFEVar> inputWindow) {
        final DFEVar[] pixelChoices = new DFEVar[getKernelIterations()];
        for (int i = 0; i < getKernelIterations() ; i++) {
            int idx = multiplierNumber + i * layerParams.getConv().getKernelFoldingFactor();

            if (idx < inputWindow.getSize()) {
                pixelChoices[i] = inputWindow[idx];
            } else {
                pixelChoices[i] = constant.var(GlobalConfig.dataType, 0);
            }
        }

        switch (getWeightsLoadStrategy()) {
        case INIT_FROM_CPU:
            if (getKernelIterations() == 1) {
                return inputWindow[multiplierNumber];
            }
            return control.mux(cpuInitWeightsCounter.getKernelIter(), pixelChoices);

        case STREAM_FROM_LMEM:
            return null;

        case WITH_CACHE:
            Memory<DFEVar> pixelsMem = mem.alloc(GlobalConfig.dataType, getKernelIterations());
            DFEVar pixel = control.mux(lookAheadCounter.getKernelIter(), pixelChoices);
            pixelsMem.write(
                    lookAheadCounter.getKernelIter(),
                    pixel,
                    lookAheadCounter.getPixelWriteEnable());
            return (lookAheadCounter.getPixelWriteEnable()
                    ? pixel
                    : pixelsMem.read(lookAheadCounter.getKernelIter()));
        }

        /* Makes compiler happy. */
        return null;
    }

    private DFEVector<DFEVar> getLMemWeightsInput() {
        final int size =
                layerParams.getConv().getWorkerFactor()
                * layerParams.getConv().getConvFoldingFactor()
                * layerParams.getConv().getKernelFoldingFactor();
        DFEVectorType<DFEVar> weightInputType = new DFEVectorType<DFEVar>(
                GlobalConfig.dataType, size);
        DFEVectorType<DFEVar> rawWeightInputType = new DFEVectorType<DFEVar>(
                GlobalConfig.cpuType, size);

        if (lmemWeightsInput != null) {
            return lmemWeightsInput;

        } else if (getWeightsLoadStrategy() == WeightsLoadStrategy.WITH_CACHE
                || getWeightsLoadStrategy() == WeightsLoadStrategy.STREAM_FROM_LMEM) {
            lmemWeightsInput = io.input(
                    getLMemWeightName(),
                    rawWeightInputType,
                    lookAheadCounter.getWeightsInputFlag()).cast(weightInputType);
            return lmemWeightsInput;

        } else {
            throw new RuntimeException("getLMemWeightsInput() should only be used from a"
                    + " LMem-initialized weights net.");

        }

        
    }

    private DFEVector<DFEVar> getCpuWeightsInput() {
        if (cpuWeightsInput != null) {
            return cpuWeightsInput;

        } else if (getWeightsLoadStrategy() == WeightsLoadStrategy.INIT_FROM_CPU) {
            DFEVectorType<DFEVar> weightInputVectorType = new DFEVectorType<DFEVar>(
                    GlobalConfig.dataType, layerParams.getConv().getKernelFoldingFactor());
            DFEVectorType<DFEVar> rawWeightInputVectorType = new DFEVectorType<DFEVar>(
                    GlobalConfig.cpuType, layerParams.getConv().getKernelFoldingFactor());
            DFEVector<DFEVar> rawWeightsInputs = io.input(
                    getCpuWeightsInputName(),
                    rawWeightInputVectorType,
                    cpuInitWeightsCounter.getWeightsInputFlag());
            cpuWeightsInput = rawWeightsInputs.cast(weightInputVectorType);
            return cpuWeightsInput;

        } else {
            throw new RuntimeException("getCpuWeightsInput() should only be used from a"
                    + " host-initialized weights net.");

        }

    }

    public DFEVar getConvWeights(
            int workerId, int convUnitIndex, int multId, DFEVar address) {
        Memory<DFEVar> filtersRom = null;

        switch (getWeightsLoadStrategy()) {
        case INIT_FROM_CPU:
            filtersRom = mem.alloc(
                    GlobalConfig.dataType, totalAddressCount);
            filtersRom.write(
                    address,
                    getCpuWeightsInput()[multId],
                    cpuInitWeightsCounter.getWriteEnable(workerId, convUnitIndex));
            return filtersRom.read(address);

        case STREAM_FROM_LMEM:
            return null;

        case WITH_CACHE:
            filtersRom = mem.alloc(GlobalConfig.dataType, totalAddressCount);
            int idx = workerId;
            idx = (idx * convParams.getConvFoldingFactor()) + convUnitIndex;
            idx = (idx * convParams.getKernelFoldingFactor()) + multId;

            DFEVar weightInput = getLMemWeightsInput()[idx];
            filtersRom.write(
                    lookAheadCounter.getAddress(),
                    weightInput,
                    lookAheadCounter.getWriteEnable());
            return (lookAheadCounter.getWriteEnable()
                    ? weightInput 
                    : filtersRom.read(lookAheadCounter.getAddress()));

        }

        /* Makes compiler happy. */
        return null;
    }

    public int lmemStreamSizePerImage() {
        int totalPixels =
                layerParams.getOutputHeight() * layerParams.getOutputWidth()
                / layerParams.getConv().getLookAhead();
        return getTotalIterations() * totalPixels;
    }
}
