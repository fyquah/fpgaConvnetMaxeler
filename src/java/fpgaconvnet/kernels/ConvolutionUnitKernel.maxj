package fpgaconvnet.kernels;

import java.lang.RuntimeException;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;

import fpgaconvnet.GlobalConfig;
import fpgaconvnet.IterationCounter;
import fpgaconvnet.Utils;
import fpgaconvnet.protos.Parameters.LayerParameter;
import fpgaconvnet.protos.Parameters.ConvolutionParameter;
import fpgaconvnet.lib.CpuInitWeightsCounter;
import fpgaconvnet.lib.LookAheadCounter;


public class ConvolutionUnitKernel extends ConvolutionKernelBase {

    public enum WeightsLoadStrategy {
        INIT_FROM_CPU,
        STREAM_FROM_LMEM,
        WITH_CACHE,
    };

    private final int kernelDim;
    private final DFEVectorType<DFEVar> inputVectorType;
    private final DFEVectorType<DFEVar> outputVectorType;
    private final LayerParameter layerParams;
    private final ConvolutionParameter convParams;
    private final int convFoldingFactor;
    private final int kernelFoldingFactor;
    private final int totalAddressCount;
    private final IterationCounter ctr;

    private DFEVector<DFEVar> lmemWeightsInput = null;
    private DFEVector<DFEVar> cpuWeightsInput = null;
    private CpuInitWeightsCounter cpuInitWeightsCounter = null;
    private LookAheadCounter lookAheadCounter = null;

    public ConvolutionUnitKernel(KernelParameters kp, LayerParameter params) {
        super(kp, params);
        convParams = params.getConv();
        layerParams = params;
        kernelDim = params.getConv().getKernelSize();

        ctr = new IterationCounter(layerParams);
        inputVectorType = new DFEVectorType<DFEVar>(GlobalConfig.dataType, kernelDim * kernelDim);
        outputVectorType = new DFEVectorType<DFEVar>(
                GlobalConfig.dataType, layerParams.getConv().getConvFoldingFactor());

        convFoldingFactor = layerParams.getConv().getConvFoldingFactor();
        kernelFoldingFactor = layerParams.getConv().getKernelFoldingFactor();
        totalAddressCount = iterCounter.getWeightIterations() * getKernelIterations();

        DFEVar inputControlFlag = null;
        DFEVar outputControlFlag = null;

        switch (getWeightsLoadStrategy()) {
        case INIT_FROM_CPU:
            cpuInitWeightsCounter = new CpuInitWeightsCounter(this, layerParams);
            inputControlFlag = cpuInitWeightsCounter.getInputControlFlag();
            outputControlFlag = cpuInitWeightsCounter.getOutputControlFlag();
            break;

        case STREAM_FROM_LMEM:
        case WITH_CACHE:
            lookAheadCounter = new LookAheadCounter(this, layerParams);
            inputControlFlag = lookAheadCounter.getInputControlFlag();
            outputControlFlag = lookAheadCounter.getOutputControlFlag();
            break;

        }

        for (int workerId = 0 ; workerId < params.getConv().getWorkerFactor() ; workerId++) {

            DFEVector<DFEVar> inputWindow = io.input(
                    getInputName(workerId), inputVectorType, inputControlFlag);

            DFEVector<DFEVar> output = outputVectorType.newInstance(this);
            final DFEVar[] pixelVars = new DFEVar[layerParams.getConv().getKernelFoldingFactor()];
            final DFEVar[][] weightVars = new DFEVar[convFoldingFactor][kernelFoldingFactor];

            for (int multId = 0; multId < layerParams.getConv().getKernelFoldingFactor(); multId++) {
                pixelVars[multId] = getConvPixel(multId, inputWindow);
            }

            for (int convUnitIndex = 0; convUnitIndex < convFoldingFactor; convUnitIndex++) {
                DFEVar convUnitOutput = constant.var(GlobalConfig.dataType, 0.0);

                for (int multId = 0; multId < kernelFoldingFactor; multId++) {

                    /* Determine the weight fetching strategy based on the foldingFactors. */
                    weightVars[convUnitIndex][multId] = getConvWeights(
                            workerId, convUnitIndex, multId);

                    convUnitOutput = convUnitOutput
                            + pixelVars[multId] * weightVars[convUnitIndex][multId];

                }
                output[convUnitIndex] <== convUnitOutput;
            }

            io.output(getOutputName(workerId), output, outputVectorType, outputControlFlag);

            if (workerId == 0) {
                if (cpuInitWeightsCounter != null) {
                    cpuInitWeightsCounter.getWeightAddress().simWatch("weight_addr");
                    cpuInitWeightsCounter.getWeightsInputFlag().simWatch("init_weights");
                    cpuInitWeightsCounter.getConvIter().simWatch("conv_iter");
                    cpuInitWeightsCounter.getKernelIter().simWatch("kernel_iter");
                }
                if (lookAheadCounter != null) {
                    lookAheadCounter.getPixelAddress().simWatch("pixel_address");
                    lookAheadCounter.getWeightAddress().simWatch("weight_address");
                }
                inputControlFlag.simWatch("input_control_flag");
                weightVars[0][0].simWatch("weight");
                pixelVars[0].simWatch("pixel");
            }
        }
    }

    /* initCycles used only in CPU initialization. */
    public int stallInitCycles() {
        return initCycles() - realInitCycles();
    }

    public int realInitCycles() {
        return layerParams.getConv().getWorkerFactor()
                * layerParams.getConv().getConvFoldingFactor()
                * getSchedulerIterations()
                * getConvolutionIterations()
                * getKernelIterations();
    }

    public int initCycles() {
        /* Return different values based on caching strategy. */
        int multipleBase =
                ((int) Utils.lcm(4, layerParams.getConv().getKernelFoldingFactor()))
                / layerParams.getConv().getKernelFoldingFactor();
        return Utils.divCeil(realInitCycles(), multipleBase) * multipleBase;
    }

    public int initStreamSize() {
        // size of every weight input Vector.
        return initCycles() * layerParams.getConv().getKernelFoldingFactor();
    }

    public int cyclesPerImage() {
        int totalOutputPixels = layerParams.getOutputHeight() * layerParams.getOutputWidth();
        int cyclesPerPixel = getSchedulerIterations()
                * getConvolutionIterations()
                * getKernelIterations();
        return totalOutputPixels * cyclesPerPixel;
    }

    public String getInputName(int workerId) {
        return "input_" + workerId;
    }

    public String getCpuWeightsInputName() {
        return "weights_input";
    }

    public String getLMemWeightName() {
        return "weight_lmem";
    }

    public String getOutputName(int workerId) {
        return "output_" + workerId;
    }

    public WeightsLoadStrategy getWeightsLoadStrategy() {
        int totalRomSize =
                getConvolutionIterations() * getSchedulerIterations()
                * (convParams.getWorkerFactor() * convParams.getConvFoldingFactor());
        if (convParams.getBramFactor() >= totalRomSize) {
            return WeightsLoadStrategy.INIT_FROM_CPU;

        } else if (convParams.getLookAhead() == 1) {
            return WeightsLoadStrategy.STREAM_FROM_LMEM;

        } else {
            return WeightsLoadStrategy.WITH_CACHE;

        }
    }

    private DFEVar getConvPixel(
            int multiplierNumber, DFEVector<DFEVar> inputWindow) {
        final DFEVar[] pixelChoices = new DFEVar[getKernelIterations()];
        for (int i = 0; i < getKernelIterations() ; i++) {
            int idx = multiplierNumber + i * layerParams.getConv().getKernelFoldingFactor();

            if (idx < inputWindow.getSize()) {
                pixelChoices[i] = inputWindow[idx];
            } else {
                pixelChoices[i] = constant.var(GlobalConfig.dataType, 0);
            }
        }

        switch (getWeightsLoadStrategy()) {
        case INIT_FROM_CPU:
            if (getKernelIterations() == 1) {
                return inputWindow[multiplierNumber];
            }
            return control.mux(cpuInitWeightsCounter.getKernelIter(), pixelChoices);

        case STREAM_FROM_LMEM:
        case WITH_CACHE:
            /* This is fine because weightIterations is constrainted to be either a factor or
             * a multiple (the if-case) of convolutionIterations()
             */
            if (ctr.getWeightIterations() >= ctr.getConvolutionIterations()) {
                if (pixelChoices.length == 1) {
                    return pixelChoices[0];
                }
                return control.mux(lookAheadCounter.getKernelIter(), pixelChoices);

            } else {
                Memory<DFEVar> pixelsMem = mem.alloc(
                        GlobalConfig.dataType,
                        Math.max(2, convParams.getLookAhead() * getKernelIterations()));
                DFEVar pixel = control.mux(lookAheadCounter.getKernelIter(), pixelChoices);
                pixelsMem.write(
                        lookAheadCounter.getPixelAddress(),
                        pixel,
                        lookAheadCounter.getPixelWriteEnable());

                return (lookAheadCounter.getPixelWriteEnable()
                        ? pixel
                        : pixelsMem.read(lookAheadCounter.getPixelAddress()));

            }
        }

        /* Makes compiler happy. */
        return null;
    }

    private int getWeightInputSize() {
        final int size =
                layerParams.getConv().getWorkerFactor()
                * layerParams.getConv().getConvFoldingFactor()
                * layerParams.getConv().getKernelFoldingFactor();
        return Utils.divCeil(size, GlobalConfig.burstSizeBytes / 4)
                * (GlobalConfig.burstSizeBytes / 4);
    }

    private DFEVector<DFEVar> getLMemWeightsInput() {

        /* TODO(fyq14): Optimize this. */
        DFEVectorType<DFEVar> weightInputType = new DFEVectorType<DFEVar>(
                GlobalConfig.dataType, getWeightInputSize());
        DFEVectorType<DFEVar> rawWeightInputType = new DFEVectorType<DFEVar>(
                GlobalConfig.cpuType, getWeightInputSize());

        if (lmemWeightsInput != null) {
            return lmemWeightsInput;

        } else if (getWeightsLoadStrategy() == WeightsLoadStrategy.WITH_CACHE
                || getWeightsLoadStrategy() == WeightsLoadStrategy.STREAM_FROM_LMEM) {
            DFEVector<DFEVar> rawInputWeight = io.input(
                    getLMemWeightName(),
                    rawWeightInputType,
                    lookAheadCounter.getWeightsInputFlag());
            lmemWeightsInput = rawInputWeight.cast(weightInputType);

            return lmemWeightsInput;

        } else {
            throw new RuntimeException("getLMemWeightsInput() should only be used from a"
                    + " LMem-initialized weights net.");

        }

        
    }

    private DFEVector<DFEVar> getCpuWeightsInput() {
        if (cpuWeightsInput != null) {
            return cpuWeightsInput;

        } else if (getWeightsLoadStrategy() == WeightsLoadStrategy.INIT_FROM_CPU) {
            DFEVectorType<DFEVar> weightInputVectorType = new DFEVectorType<DFEVar>(
                    GlobalConfig.dataType, layerParams.getConv().getKernelFoldingFactor());
            DFEVectorType<DFEVar> rawWeightInputVectorType = new DFEVectorType<DFEVar>(
                    GlobalConfig.cpuType, layerParams.getConv().getKernelFoldingFactor());
            DFEVector<DFEVar> rawWeightsInputs = io.input(
                    getCpuWeightsInputName(),
                    rawWeightInputVectorType,
                    cpuInitWeightsCounter.getWeightsInputFlag());
            cpuWeightsInput = rawWeightsInputs.cast(weightInputVectorType);
            return cpuWeightsInput;

        } else {
            throw new RuntimeException("getCpuWeightsInput() should only be used from a"
                    + " host-initialized weights net.");

        }

    }

    private Memory<DFEVectorType<DFEVar>> filtersRom = null;
    private DFEVector<DFEVar> cycleWeightsRead = null;
    private DFEVectorType<DFEVar> weightsMemoryType = null;

    private Memory<DFEVectorType<DFEVar>> retrieveWeightsRom() {
        if (filtersRom != null) {
            return filtersRom;
        }

        switch (getWeightsLoadStrategy()) {
        case INIT_FROM_CPU:
        case WITH_CACHE:
            weightsMemoryType = new DFEVectorType<DFEVar>(
                    GlobalConfig.dataType, getTotalMultipliers());

        default:
            throw new RuntimeException("Retrieve weight roms failed");
        }

        return filtersRom = mem.alloc(weightsMemoryType, totalAddressCount);
    }

    private int getTotalMultipliers() {
        return convParams.getWorkerFactor()
                * convParams.getConvFoldingFactor()
                * convParams.getKernelFoldingFactor();
    }

    private DFEVector<DFEVar> retrieveCycleWeightsRead() {
        if (cycleWeightsRead != null) {
            return cycleWeightsRead;
        }

        if (getWeightsLoadStrategy() == WeightsLoadStrategy.INIT_FROM_CPU) {
            filtersRom = retrieveWeightsRom();
            DFEVector<DFEVar> inputVec = getCpuWeightsInput();
            DFEVector<DFEVar> originalVec = filtersRom.read(cpuInitCounter.getWeightAddress())
            DFEVector<DFEVar> newVec = weightsMemoryType.newInstance(this);

            for (int worker = 0 ; worker < convParams.getWorkerFactor() ; worker++) {
                for (int conv = 0 ; conv < convParams.getConvolutionFactor() ; conv++) {
                    for (int mult = 0 ; mult < convParams.getKernelFoldingFacotr() ; mult++) {
                        int idx = (
                                (worker * (convParams.getConvFoldingFactor()
                                           * convParams.getKernelFoldingFactor()))
                                + (conv * convParams.getKernelFoldingFactor())
                                + mult);
                        newVec[idx] = (
                                cpuInitCounter.getWriteEnable(worker, conv)
                                ? inputVec[mult]
                                : originalVec[idx]);
                    }
                }
            }

            filtersRom.write(
                    cpuInitWeightsCounter.getWeightAddress(),
                    newVec,
                    cpuinitCounter.getWriteEnable());
            return cycleWeightsRead = originalVec;

        } else if (getWeightsLoadStrategy() == WeightsLoadStrategy.WITH_CACHE) {
            filtersRom = retrieveWeightsRom();
            DFEVector<DFEVar> inputVec = getLMemWeightsInput();
            DFEVector<DFEVar> originalVec = filtersRom.read(lookAheadCounter.getWriteAddress());

            filtersRom.write(
                    cpuInitWeightsCounter.getWeightAddress(),
                    inputVec.slice(0, getTotalMultipliers),
                    lookAheadCounter.getWeightWriteEnable());
            return cycleWeightsRead = originalVec;

        } else {
            throw new RuntimeException(
                    "cannot retrieve cycle on chip in streaming from LMem.");
        }
    }


    public DFEVar getConvWeights(
            int workerId, int convUnitIndex, int multId) {
        Memory<DFEVar> filtersRom = null;
        int idx;

        switch (getWeightsLoadStrategy()) {
        case INIT_FROM_CPU:
        case WITH_CACHE:
            DFEVector<DFEVar> weightsVec = retrieveCycleWeightsRead();

            idx = workerId;
            idx = (idx * convParams.getConvFoldingFactor()) + convUnitIndex;
            idx = (idx * convParams.getKernelFoldingFactor()) + multId;

            return retrieveCycleWeightsRead()[idx]

        case STREAM_FROM_LMEM:
            idx = workerId;
            idx = (idx * convParams.getConvFoldingFactor()) + convUnitIndex;
            idx = (idx * convParams.getKernelFoldingFactor()) + multId;
            return getLMemWeightsInput()[idx];

            filtersRom = mem.alloc(GlobalConfig.dataType, totalAddressCount);
            idx = workerId;
            idx = (idx * convParams.getConvFoldingFactor()) + convUnitIndex;
            idx = (idx * convParams.getKernelFoldingFactor()) + multId;

            DFEVar weightInput = getLMemWeightsInput()[idx];
            filtersRom.write(
                    lookAheadCounter.getWeightAddress(),
                    weightInput,
                    lookAheadCounter.getWeightWriteEnable());
            return (lookAheadCounter.getWeightWriteEnable()
                    ? weightInput 
                    : filtersRom.read(lookAheadCounter.getWeightAddress()));

        }

        /* Makes compiler happy. */
        return null;
    }

    public int lmemStreamSizePerPixel() {
        return getTotalIterations() * getWeightInputSize();
    }
}
