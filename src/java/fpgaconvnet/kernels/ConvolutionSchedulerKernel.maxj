package fpgaconvnet.kernels;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;

import fpgaconvnet.IterationCounter;
import fpgaconvnet.SlidingWindow;
import fpgaconvnet.Dimension;
import fpgaconvnet.GlobalConfig;
import fpgaconvnet.Utils;
import fpgaconvnet.Utils.Pair;
import fpgaconvnet.kernels.ConvolutionKernelBase;
import fpgaconvnet.lib.StrideCounter;
import fpgaconvnet.protos.Parameters.LayerParameter;

/* 
 * io.input:
 *  x : DFEVector[inputChannels] 
 * io.output:
 *  - y0, y1, y2, ...., y{workerFactor - 1}
 *  where y_i is a vector of length kernelDim * kernelDim.
 *
 * When the number of workers is a factor of the number of input channels, the outputs are
 * scheduled as such, for example in the case of three workers and n_in input channels.
 *
 * - worker 0: {0, 3, ..., n_in - 3}
 * - worker 1: {1, 4, ..., n_in - 2}
 * - worker 2: {2, 5, ..., n_in - 1}
 */

public class ConvolutionSchedulerKernel extends ConvolutionKernelBase {
    private final DFEVectorType<DFEVar> inputVectorType, outputVectorType;
    private final SlidingWindow[] slidingWindows;
    private final DFEVector<DFEVar> input;
    private final List<DFEVector<DFEVar>> output_y;
    private final Dimension inputDimension;
    private final int kernelDim, workerFactor;
    private final DFEVar iter, row, col;
    private final CounterChain masterChain;
    private final LayerParameter layerParams;
    private final IterationCounter ctr;
    private final OffsetCounter offsetCounter;

    public ConvolutionSchedulerKernel(KernelParameters kp, LayerParameter argLayerParams) {
        super(kp, argLayerParams);

        layerParams = argLayerParams;
        ctr = new IterationCounter(layerParams);
        offsetCounter = new OffsetCounter();
        inputDimension = Utils.layerInputDimension(layerParams);
        kernelDim = layerParams.getConv().getKernelSize();
        workerFactor = layerParams.getConv().getWorkerFactor();
        masterChain = control.count.makeCounterChain();
        inputVectorType = new DFEVectorType<DFEVar>(
                GlobalConfig.dataType,
                inputDimension.channels());
        outputVectorType = new DFEVectorType<DFEVar>(GlobalConfig.dataType, kernelDim * kernelDim);
        input = inputVectorType.newInstance(this);
        output_y = new ArrayList<DFEVector<DFEVar>>();;
        slidingWindows = new SlidingWindow[inputDimension.channels()];
        for (int i = 0 ; i < workerFactor; i++) {
            output_y.add(outputVectorType.newInstance(this));
        }
        for (int i = 0 ; i < inputDimension.channels() ; i++) {
            slidingWindows[i] = new SlidingWindow(
                this,
                input[i],
                inputDimension.height(),
                inputDimension.width(),
                kernelDim,
                getSchedulerIterations(),
                constant.var(GlobalConfig.dataType, 0.0),
                -(kernelDim / 2));
        }
        row = Utils.chainCounterOrZero(this, masterChain, inputDimension.height());
        col = Utils.chainCounterOrZero(this, masterChain, inputDimension.width());
        iter = Utils.chainCounterOrZero(this, masterChain, getSchedulerIterations());

        CounterChain newChain = control.count.makeCounterChain();
        DFEVar streamlookAheadIter = Utils.chainCounterOrZero(
                this, newChain, layerParams.getConv().getLookAhead());
        Utils.chainCounterOrZero(this, newChain, getSchedulerIterations());

        StrideCounter strideCounter = new StrideCounter(
                this,
                layerParams.getConv().getStride(),
                ~isBorder(row, col)
                    & col.eq(inputDimension.width() - 1)
                    & iter.eq(getSchedulerIterations() - 1),
                ~isBorder(row, col)
                    & iter.eq(getSchedulerIterations() - 1),
                iter.eq(getSchedulerIterations() - 1)
                    & col.eq(inputDimension.width() - 1)
                    & row.eq(inputDimension.height() - 1));
        DFEVar outputControlFlag = strideCounter.isOutputReady() & ~isBorder(row, col);

        if (layerParams.getIsFirstLayer()) {
            /* First layer - cast from dfefloat to fixed point. */
            DFEVectorType<DFEVar> rawInputVectorType = new DFEVectorType<DFEVar>(
                    GlobalConfig.cpuType, inputDimension.channels());
            DFEVector<DFEVar> rawInput = io.input(
                    getInputName(), rawInputVectorType, iter.eq(0));

            for (int i = 0 ; i < inputDimension.channels() ; i++) {
                input[i] <== rawInput[i].cast(GlobalConfig.dataType);
            }
        } else {
            input <== io.input(getInputName(), inputVectorType, iter.eq(0));
        }

        for (int workerId = 0 ; workerId < workerFactor ; workerId++) {
            List<Integer> channelList = getSchedulerChannels(workerId);

            if (layerParams.getConv().getLookAhead() == 1) {
                DFEVector<DFEVar> pixelWindow = toMuxedPixelChecked(iter, channelList);
                output_y[workerId] <== pixelWindow;

            } else {
                DFEVar batchIter = control.count.simpleCounter(
                        Utils.ceilLog2(
                                getSchedulerIterations() * layerParams.getConv().getLookAhead()),
                        getSchedulerIterations() * layerParams.getConv().getLookAhead());

                DFEVector<DFEVar> pixelWindow = toMuxedPixelChecked(iter, channelList);
                CounterChain chain = control.count.makeCounterChain();
                Pair<Integer, Integer> minmax = offsetCounter.computeOffsetMinMax();
                DFEType thresholdType =
                        dfeUInt(1 + Utils.ceilLog2(offsetCounter.getNormalZMax()));
                DFEType offsetType = dfeInt(1 + Utils.ceilLog2(
                    getSchedulerIterations() * layerParams.getConv().getLookAhead()));

                DFEVar x = Utils.chainCounterOrZero(
                        this, chain, offsetCounter.getXMax(), offsetCounter.getXInc());
                DFEVar y = Utils.chainCounterOrZero(
                        this, chain, offsetCounter.getYMax(), offsetCounter.getYInc());
                DFEVar z;

                if (offsetCounter.getNormalZMax() == offsetCounter.getLastZMax()) {
                    z = Utils.chainCounterOrZero(
                        this, chain, offsetCounter.getNormalZMax());

                } else {
                    int threshold =
                            layerParams.getConv().getLookAhead()
                            * (ctr.getRevisitIterations() - 1)
                            * offsetCounter.getNormalZMax();
                    z = chain.addCounter(
                            (batchIter < threshold)
                             ? constant.var(thresholdType, offsetCounter.getNormalZMax())
                             : constant.var(thresholdType, offsetCounter.getLastZMax())
                            , 1);

                }
                DFEVar offsetFromBeginning = x.cast(offsetType) + y.cast(offsetType) + z.cast(offsetType);
                DFEVar offset = offsetFromBeginning - batchIter.cast(offsetType);

                output_y[workerId] <== stream.offset(
                        pixelWindow, offset, minmax.getFirst(), minmax.getSecond());

                streamlookAheadIter.simWatch("lookahead");
                iter.simWatch("iter");
                toMuxedPixel(iter, channelList)[0].simWatch("original");
                output_y[workerId][0].simWatch("output");
            }
            io.output(getOutputName(workerId),
                      output_y[workerId],
                      outputVectorType,
                      outputControlFlag);
        }
    }

    public int cyclesPerImage() {
        return (inputDimension.width() * inputDimension.height() * getSchedulerIterations());
    }

    public String getInputName() {
        return "input";
    }

    public String getOutputName(int workerId) {
        return "output_x_" + workerId;
    }

    protected DFEVar isBorder(DFEVar row, DFEVar col) {
        DFEVar flag = constant.var(dfeBool(), 0);
        for (int i = 0 ; i < ((kernelDim - 1) / 2) - layerParams.getConv().getPad() ; i++) {
            flag = flag | row.eq(i) | col.eq(i)
                | row.eq(inputDimension.height() - 1 - i)
                | col.eq(inputDimension.width() - 1 - i);
        }

        return flag;
    }

    protected DFEVector<DFEVar> zeroVector(DFEVectorType<DFEVar> type) {
        DFEVector<DFEVar> newVector = type.newInstance(this);

        for (int i = 0 ; i < newVector.getSize() ; i++) {
            newVector[i] <== constant.var(GlobalConfig.dataType, 0);
        }

        return newVector;
    }

    protected DFEVector<DFEVar> toMuxedPixelChecked(DFEVar iter, List<Integer> channels) {
        Utils.assertTrue(channels.size() == getSchedulerIterations());
        return toMuxedPixel(iter, channels);
    }

    protected DFEVector<DFEVar> toMuxedPixel(DFEVar iter, List<Integer> channels) {
        Utils.assertTrue(channels.size() != 0);

        if (channels.size() == 1) {
            return slidingWindows[channels[0]].output;
        }

        List<DFEVector<DFEVar>> arr = new ArrayList<DFEVector<DFEVar>>();
        for (int chan : channels) {
            if (chan != -1) {
                arr.add(slidingWindows[chan].output);
            } else {
                arr.add(zeroVector(outputVectorType));
            }
        }
        return control.mux(iter, arr);
    }


    protected class OffsetCounter {
        protected int getLastZMax() {
            return Math.max(1, ctr.getLastWeightIterations() / getConvolutionIterations());
        }

        protected int getNormalZMax() {
            return Math.max(1, ctr.getWeightIterations() / getConvolutionIterations());
        }

        protected int getYInc() {
            return getSchedulerIterations();
        }

        protected int getYMax() {
            return getYInc() * layerParams.getConv().getLookAhead();
        }

        protected int getXMax() {
            return getXInc() * Utils.divCeil(getSchedulerIterations(), getXInc());
        }

        protected int getXInc() {
            return Math.max(1, ctr.getWeightIterations() / ctr.getConvolutionIterations());
        }

        protected Pair<Integer, Integer> computeOffsetMinMax() {
            int min = (1 << 29);
            int max = -(1 << 29);
            int ctr = 0;

            for (int x = 0; x < getXMax() ; x += getXInc()) {
                for (int y = 0 ; y < getYMax() ; y += getYInc()) {
                    int zMax = (x == (getXMax() - getXInc())) ? getLastZMax() : getNormalZMax();

                    for (int z = 0 ; z < zMax ; z += 1) {
                        int offset = (x + y + z) - ctr;
                        System.out.println(x + " " + y + " " + z);
                        System.out.println("x + y + z = " + (x + y + z));
                        System.out.println("offset = " + offset);

                        if (offset < min) {
                            min = offset;
                        }
                        if (offset > max) {
                            max = offset;
                        }
                        ctr++;
                    }
                }
            }

            return new Pair<Integer, Integer>(min, max);
        }
    }

    /* It should be possible to solve this using some kind of number theory magic. But I am no
     * mathematician :/
     */
}
