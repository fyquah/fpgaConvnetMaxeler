package fpgaconvnet;
import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import fpgaconvnet.protos.Parameters.LayerParameter;


public class ConvolutionUnitKernel extends ConvolutionKernelBase {

    private final int kernelDim;
    private final int totalWeights;
    private final DFEVectorType<DFEVar> inputVectorType;
    private final DFEVectorType<DFEVar> outputVectorType;
    private final DFEVector<DFEVar> inputWindow;
    private final DFEVector<DFEVar> output;
    private final Memory<DFEVar> filtersRom;
    private final LayerParameter layerParams;

    public ConvolutionUnitKernel(KernelParameters kp, LayerParameter params, int workerId) {
        super(kp, params);
        layerParams = params;
        kernelDim = params.getConv().getKernelSize();

        inputVectorType = new DFEVectorType<DFEVar>(GlobalConfig.dataType, kernelDim * kernelDim);
        outputVectorType = new DFEVectorType<DFEVar>(
                GlobalConfig.dataType, layerParams.getConv().getConvFoldingFactor());
        inputWindow = inputVectorType.newInstance(this);
        output = outputVectorType.newInstance(this);
        totalWeights =
                getSchedulerIterations() * layerParams.getNumOutputs() * kernelDim * kernelDim;

        filtersRom = mem.alloc(GlobalConfig.dataType, totalWeights);
        filtersRom.mapToCPU(String.format("filters_layer_%d_worker_%d",
                                          params.getLayerId(), workerId));

        final int convFoldingFactor = layerParams.getConv().getConvFoldingFactor();
        final int kernelFoldingFactor = layerParams.getConv().getKernelFoldingFactor();

        CounterChain chain = control.count.makeCounterChain();
        DFEVar iter = Utils.chainCounterOrZero(this, chain, getConvolutionIterations());
        DFEVar kernelIter = Utils.chainCounterOrZero(this, chain, getKernelIterations());

        // schedule the pixel and weight vars.
        final List<DFEVar> multiplicationOutputs = new ArrayList<DFEVar>();
        final DFEVar[] pixelVars = new DFEVar[layerParams.getConv().getKernelFoldingFactor()];
        final DFEVar[][] weightVars = new DFEVar[convFoldingFactor][kernelFoldingFactor];
        for (int multId = 0; multId < layerParams.getConv().getKernelFoldingFactor(); multId++) {
            pixelVars[multId] = getConvPixel(multId, kernelIter, inputWindow);
        }
        for (int convUnitIndex = 0; convUnitIndex < convFoldingFactor; convUnitIndex++) {
            final int addressSeparation = kernelDim * kernelDim * Utils.divCeil(
                    layerParams.getNumOutputs(), layerParams.getConv().getConvFoldingFactor());
            final int addressBase = convUnitIndex * addressSeparation;
            final int addressIncrement = layerParams.getConv().getKernelFoldingFactor();
            final int addressBaseMax =
                    (convUnitIndex + 1) * addressSeparation
                    + 1 - layerParams.getConv().getKernelFoldingFactor();

            DFEVar convUnitOutput = constant.var(GlobalConfig.dataType, 0.0);
            for (int multId = 0; multId < kernelFoldingFactor; multId++) {
                Counter addressCounter = control.count.makeCounter(
                        control.count.makeParams(Utils.ceilLog2(addressBaseMax))
                            .withCountMode(Count.CountMode.NUMERIC_INCREMENTING)
                            .withInc(addressIncrement)
                            .withInitValue(addressBase + multId)
                            .withMax(addressBaseMax + multId)
                            .withWrapMode(Count.WrapMode.COUNT_LT_MAX_THEN_WRAP));
                weightVars[convUnitIndex][multId] = filtersRom.read(
                        addressCounter.getCount().cast(dfeUInt(Utils.ceilLog2(totalWeights))));
                convUnitOutput = convUnitOutput
                        + pixelVars[multId] * weightVars[convUnitIndex][multId];
            }
            output[convUnitIndex] <== convUnitOutput;
        }

        DFEVar inputControlFlag = iter.eq(0) & kernelIter.eq(0);
        inputWindow <== io.input(getInputName(), inputVectorType, inputControlFlag);
        io.output(getOutputName(), output, outputVectorType);

        // debugging
        String s_window = "[\n";
        String s_weights = "[\n";
        DFEVar[] debugValues = new DFEVar[4 + kernelDim * kernelDim
                                          + convFoldingFactor * kernelFoldingFactor] ;
        debugValues[0] = inputControlFlag;
        debugValues[1] = iter;
        debugValues[2] = kernelIter;
        debugValues[3] = output[0];
        for (int i = 0 ; i < kernelDim ; i++) {
            s_window += "[";
            for (int j = 0; j < kernelDim ; j++) {
                s_window += "%.3f, "; 
                debugValues[4 + i * kernelDim + j] = inputWindow[i * kernelDim + j];
            }
            s_window += "],\n";
        }
        s_window += "]\n";
        for (int convUnitId = 0 ; convUnitId < convFoldingFactor ; convUnitId++) {
            s_weights += "[";
            for (int multId = 0; multId < kernelFoldingFactor ; multId++) {
                s_weights += "%.3f, "; 
                int idx = 4 + kernelDim * kernelDim + convUnitId * kernelFoldingFactor + multId;
                debugValues[idx] = weightVars[convUnitId][multId];
            }
            s_weights += "]\n";
        }
        s_weights += "]\n";
        debug.simPrintf("ConvolutionUnitKernel[layer = " + params.getLayerId()
                        + "] worker = " + workerId
                        + " inputControlFlag = %d iter = %d kernelIter = %d output[0] = %.3f\n"
                        + "input window = " + s_window 
                        + "weights = " + s_weights,
                        debugValues);
    }

    public int cyclesPerImage() {
        int totalOutputPixels = layerParams.getOutputHeight() * layerParams.getOutputWidth();
        int cyclesPerPixel = getSchedulerIterations()
                * getConvolutionIterations()
                * getKernelIterations();
        return totalOutputPixels * cyclesPerPixel;
    }

    public String getInputName() {
        return "input";
    }

    public String getOutputName() {
        return "output";
    }

    private DFEVar getConvPixel(
            int multiplierNumber, DFEVar kernelIter, DFEVector<DFEVar> inputWindow) {
        if (getKernelIterations() == 1) {
            return inputWindow[multiplierNumber];
        }
        final DFEVar[] pixelChoices = new DFEVar[getKernelIterations()];
        for (int i = 0; i < getKernelIterations() ; i++) {
            int idx = i + multiplierNumber * getKernelIterations();
            pixelChoices[i] = inputWindow[idx];
        }
        return control.mux(kernelIter, pixelChoices);
    }
}
