package fpgaconvnet;
import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;

import fpgaconvnet.protos.Parameters.LayerParameter;


public class ConvolutionUnitKernel extends ConvolutionKernelBase {

    private final int kernelDim;
    private final DFEVectorType<DFEVar> inputVectorType;
    private final DFEVectorType<DFEVar> outputVectorType;
    private final List<Memory<DFEVar>> filtersRomList;
    private final LayerParameter layerParams;

    public ConvolutionUnitKernel(KernelParameters kp, LayerParameter params) {
        super(kp, params);
        layerParams = params;
        kernelDim = params.getConv().getKernelSize();

        inputVectorType = new DFEVectorType<DFEVar>(GlobalConfig.dataType, kernelDim * kernelDim);
        outputVectorType = new DFEVectorType<DFEVar>(
                GlobalConfig.dataType, layerParams.getConv().getConvFoldingFactor());
        filtersRomList = new ArrayList<Memory<DFEVar>>();

        final int convFoldingFactor = layerParams.getConv().getConvFoldingFactor();
        final int kernelFoldingFactor = layerParams.getConv().getKernelFoldingFactor();
        final int totalAddressCount =
                getSchedulerIterations()
                * getConvolutionIterations()
                * getKernelIterations();

        CounterChain chain = control.count.makeCounterChain();
        DFEVar iter = Utils.chainCounterOrZero(this, chain, getConvolutionIterations());
        DFEVar kernelIter = Utils.chainCounterOrZero(this, chain, getKernelIterations());
        DFEVar address = control.count.simpleCounter(
                Utils.ceilLog2(totalAddressCount), totalAddressCount);

        for (int workerId = 0 ; workerId < params.getConv().getWorkerFactor() ; workerId++) {

            DFEVector<DFEVar> inputWindow = inputVectorType.newInstance(this);
            DFEVector<DFEVar> output = outputVectorType.newInstance(this);
            final DFEVar[] pixelVars = new DFEVar[layerParams.getConv().getKernelFoldingFactor()];
            final DFEVar[][] weightVars = new DFEVar[convFoldingFactor][kernelFoldingFactor];

            for (int multId = 0; multId < layerParams.getConv().getKernelFoldingFactor(); multId++) {
                pixelVars[multId] = getConvPixel(multId, kernelIter, inputWindow);
            }

            for (int convUnitIndex = 0; convUnitIndex < convFoldingFactor; convUnitIndex++) {
                DFEVar convUnitOutput = constant.var(GlobalConfig.dataType, 0.0);

                for (int multId = 0; multId < kernelFoldingFactor; multId++) {
                    Memory<DFEVar> filtersRom = mem.alloc(GlobalConfig.dataType, totalAddressCount);
                    String romName = String.format(
                            "kernels_%d_%d_%d", workerId, convUnitIndex, multId);
                    filtersRom.mapToCPU(romName);

                    /* TODO(fyquah): Handle non divisible cases here by passing in a zero output
                     * - uses less DSP Slices. */
                    weightVars[convUnitIndex][multId] = filtersRom.read(address);
                    convUnitOutput = convUnitOutput
                            + pixelVars[multId] * weightVars[convUnitIndex][multId];

                    filtersRomList.add(filtersRom);
                }
                output[convUnitIndex] <== convUnitOutput;
            }

            DFEVar inputControlFlag = iter.eq(0) & kernelIter.eq(0);
            inputWindow <== io.input(getInputName(workerId), inputVectorType, inputControlFlag);
            io.output(getOutputName(workerId), output, outputVectorType);

            // debugging
            String s_window = "[\n";
            String s_weights = "[\n";
            String s_output = "[\n";
            List<Object> debugValues = new ArrayList<Object>();
            debugValues.add(inputControlFlag);
            debugValues.add(iter);
            debugValues.add(kernelIter);
            for (int i = 0 ; i < layerParams.getConv().getKernelFoldingFactor() ; i++) {
                s_window += "%.3f, "; 
                debugValues.add(pixelVars[i]);
            }
            s_window += "]\n";
            for (int convUnitId = 0 ; convUnitId < convFoldingFactor ; convUnitId++) {
                s_weights += "[";
                for (int multId = 0; multId < kernelFoldingFactor ; multId++) {
                    s_weights += "%.3f, "; 
                    debugValues.add(weightVars[convUnitId][multId]);
                }

                s_weights += "]\n";
            }
            s_weights += "]\n";
            for (int convUnitId = 0 ; convUnitId < convFoldingFactor;  convUnitId++) {
                debugValues.add(output[convUnitId]);
                s_output += "%.3f, ";
            }
            s_output += "]\n";
            debug.simPrintf("ConvolutionUnitKernel[layer = " + params.getLayerId()
                            + "] worker = " + workerId
                            + " inputControlFlag = %d iter = %d kernelIter = %d\n"
                            + "input window = " + s_window 
                            + "weights = " + s_weights
                            + "outputs = " + s_output,
                            debugValues.toArray(new Object[1]));
        }
    }

    public int cyclesPerImage() {
        int totalOutputPixels = layerParams.getOutputHeight() * layerParams.getOutputWidth();
        int cyclesPerPixel = getSchedulerIterations()
                * getConvolutionIterations()
                * getKernelIterations();
        return totalOutputPixels * cyclesPerPixel;
    }

    public String getInputName(int workerId) {
        return "input_" + workerId;
    }

    public String getOutputName(int workerId) {
        return "output_" + workerId;
    }

    private DFEVar getConvPixel(
            int multiplierNumber, DFEVar kernelIter, DFEVector<DFEVar> inputWindow) {
        if (getKernelIterations() == 1) {
            return inputWindow[multiplierNumber];
        }
        final DFEVar[] pixelChoices = new DFEVar[getKernelIterations()];
        for (int i = 0; i < getKernelIterations() ; i++) {
            int idx = multiplierNumber + i * layerParams.getConv().getKernelFoldingFactor();

            if (idx < inputWindow.getSize()) {
                pixelChoices[i] = inputWindow[idx];
            } else {
                pixelChoices[i] = constant.var(GlobalConfig.dataType, 0);
            }
        }
        return control.mux(kernelIter, pixelChoices);
    }
}
