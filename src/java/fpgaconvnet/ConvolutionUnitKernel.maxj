package fpgaconvnet;
import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import fpgaconvnet.protos.Parameters.LayerParameter;


public class ConvolutionUnitKernel extends ConvolutionKernelBase {

    private final Dimension outputDimension;
    private final int kernelDim;
    private final DFEVectorType<DFEVar> inputVectorType;
    private final DFEVector<DFEVar> inputWindow;
    private final DFEVar output;
    private final Memory<DFEVar> memFilters;
    private final LayerParameter layerParams;

    public ConvolutionUnitKernel(KernelParameters kp, LayerParameter params, int workerId) {
        super(kp, params);
        layerParams = params;
        kernelDim = params.getConv().getKernelSize();
        outputDimension = Utils.layerOutputDimension(params);

        inputVectorType = new DFEVectorType<DFEVar>(GlobalConfig.dataType, kernelDim * kernelDim);
        inputWindow = inputVectorType.newInstance(this);
        output = GlobalConfig.dataType.newInstance(this);

        memFilters = mem.alloc(
                GlobalConfig.dataType,
                getSchedulerIterations() * layerParams.getNumOutputs());
        memFilters.mapToCPU(String.format("filters_%d_worker_%d", params.getLayerId(), workerId));

        // schedule the pixel and weight vars.
        final List<DFEVar> multiplicationOutputs = new ArrayList<DFEVar>();
        final int convFoldingFactor = layerParams.getConv().getConvFoldingFactor();
        final int kernelFoldingFactor = layerParams.getConv().getKernelFoldingFactor();
        final DFEVar[] pixelVars = new DFEVar[layerParams.getConv().getKernelFoldingFactor()];
        final DFEVar[][] weightVars = new DFEVar[convFoldingFactor][kernelFoldingFactor];
        for (int multId = 0; multId < layerParams.getConv().getKernelFoldingFactor(); multId++) {
            pixelVars[multId] = getConvPixel(multId, inputWindow);
        }
        for (int convUnitIndex = 0; convUnitIndex < convFoldingFactor; convUnitIndex++) {
            final int addressSeparation = kernelDim * kernelDim * Utils.divCeil(
                    layerParams.getNumOutputs(), layerParams.getConv().getConvFoldingFactor());
            final int addressBase = convUnitIndex * addressSeparation;
            final int addressIncrement = layerParams.getConv().getKernelFoldingFactor();
            final int addressBaseMax =
                    (convUnitIndex + 1) * addressSeparation
                    + 1 - layerParams.getConv().getKernelFoldingFactor();

            for (int multId = 0; multId < kernelFoldingFactor; multId++) {
                Counter addressCounter = control.count.makeCounter(
                        control.count.makeParams(Utils.ceilLog2(addressBaseMax))
                            .withCountMode(Count.CountMode.NUMERIC_INCREMENTING)
                            .withInc(addressIncrement)
                            .withInitValue(addressBase + multId)
                            .withMax(addressBaseMax + multId)
                            .withWrapMode(Count.WrapMode.COUNT_LT_MAX_THEN_WRAP));
                weightVars[convUnitIndex][multId] = memFilters.read(addressCounter.getCount());
                multiplicationOutputs.add(
                        pixelVars[multId] * weightVars[convUnitIndex][multId]);
            }
        }

        // construct the actual outputs
        int totalIter = getConvolutionIterations() * getSchedulerIterations() * getKernelIterations();
        DFEVar iter = control.count.simpleCounter(Utils.ceilLog2((int) totalIter), totalIter);
        output <== Utils.treeReduceAdd(multiplicationOutputs);
        inputWindow <== io.input(getInputName(), inputVectorType, iter.eq(totalIter - 1));
        io.output(getOutputName(), output, GlobalConfig.dataType);

        // debugging
        String s_window = "[\n";
        String s_weights = "[\n";
        DFEVar[] debugValues = new DFEVar[2 + kernelDim * kernelDim
                                          + convFoldingFactor * kernelFoldingFactor] ;
        debugValues[0] = iter;
        debugValues[1] = output;
        for (int i = 0 ; i < kernelDim ; i++) {
            s_window += "[";
            for (int j = 0; j < kernelDim ; j++) {
                s_window += "%.3f, "; 
                debugValues[i * kernelDim + j] = inputWindow[i * kernelDim + j];
            }
            s_window += "],\n";
        }
        s_window += "]\n";
        for (int convUnitId = 0 ; convUnitId < convFoldingFactor ; convUnitId++) {
            s_weights += "[";
            for (int multId = 0; multId < kernelFoldingFactor ; multId++) {
                s_weights += "%.3f, "; 
                int idx = 2 + kernelDim * kernelDim + convUnitId * kernelFoldingFactor + multId;
                debugValues[idx] = weightVars[convUnitId][multId];
            }
            s_weights += "]\n";
        }
        s_weights += "]\n";
        debug.simPrintf("ConvolutionUnitKernel[layer = " + params.getLayerId()
                        + "] iter = %d output = %.3f\n"
                        + "input window = " + s_window 
                        + "weights = " + s_weights,
                        debugValues);
    }

    public int cyclesPerImage() {
        int totalOutputPixels = outputDimension.height() * outputDimension.width();
        int cyclesPerPixel = getSchedulerIterations()
                * getConvolutionIterations()
                * getKernelIterations();
        return totalOutputPixels * cyclesPerPixel;
    }

    public String getInputName() {
        return "input";
    }

    public String getOutputName() {
        return "output";
    }

    private DFEVar getConvPixel(int multiplierNumber, DFEVector<DFEVar> inputWindow) {
        final int loopIterations = Utils.divCeil(
                kernelDim * kernelDim,
                layerParams.getConv().getKernelFoldingFactor());
        final DFEVar iter = control.count.simpleCounter(loopIterations);
        final DFEVar[] pixelChoices = new DFEVar[loopIterations];
        for (int i = 0; i < loopIterations ; i++) {
            int idx = i + multiplierNumber * layerParams.getConv().getKernelFoldingFactor();
            pixelChoices[i] = inputWindow[idx];
        }
        return control.mux(iter, pixelChoices);
    }
}
