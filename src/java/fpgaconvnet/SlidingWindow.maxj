package fpgaconvnet;
// package nothing;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;

/* When the offset is defined as 0, the sliding window is identified by the top left corner of
 * the window. This is useful for cases like pooling where there is definitely no pooling layers.
 *
 * When offset is defined as kernelDim / 2, the sliding window is centered around the pixel.
 * For odd-number sliding windows, the windows are centered around the center pixel:
 * 
 * [ (-2, -2), (-1, -2), (0, -2), (1, -2), (2, -2),
 *   (-2, -1), (-1, -1), (0, -1), (1, -1), (2, -1),
 *   (-2, 0), (-1, 0), (0, 0), (1, 0), (2, 0),
 *   (-2, 1), (-1, 1), (0, 1), (1, 1), (2, 1),
 *   (-2, 2), (-2, 2), (0, 2), (1, 2), (2, 2) ]
 *
 * For even-number sliding windows, the windows are centered around the bottom-right center pixel:
 *
 * [ (-2, -2), (-1, -2), (0, -2), (1, -2)
 *   (-2, -1), (-1, -1), (0, -1), (1, -1)
 *   (-2, 0), (-1, 0), (0, 0), (1, 0)
 *   (-2, 1), (-1, 1), (0, 1), (1, 1) ]
 *
 */

public class SlidingWindow extends KernelLib {
    public final DFEVector<DFEVar> output;
    private final DFEVar row;
    private final DFEVar col;
    private final DFEVar cycle;
    private final CounterChain chain;

    // slides a 2d convolution window
    // around a input stream
    SlidingWindow(
        Kernel argKernel,
        DFEVar input,
        int inputHeight,
        int inputWidth,
        int kernelDim,
        int cyclesToHoldWindow,
        DFEVar paddedPixels,
        int offset
    ) {
        super(argKernel);
        DFEVectorType<DFEVar> vectorType = new DFEVectorType<DFEVar>(
                input.getType(),
                kernelDim * kernelDim);
        output = vectorType.newInstance(argKernel);

        chain = control.count.makeCounterChain();
        row = Utils.chainCounterOrZero(this, chain, inputHeight);
        col = Utils.chainCounterOrZero(this, chain, inputWidth);
        cycle = Utils.chainCounterOrZero(this, chain, cyclesToHoldWindow);

        final DFEType rowType = dfeInt(
                Utils.ceilLog2(inputHeight + kernelDim - 1 + offset) + 1);
        final DFEType colType = dfeInt(
                Utils.ceilLog2(inputWidth + kernelDim - 1 + offset) + 1);


        for (int i = 0 ; i < kernelDim ; i++) {
            for (int j = 0 ; j < kernelDim ; j++) {
                final int idx = ((i + offset) * inputWidth) + (j + offset);
                final int streamOffset = cyclesToHoldWindow * idx;
                final DFEVar flag =
                        ((row.cast(rowType) + (i + offset) >= 0)
                         & (row.cast(rowType) + (i + offset) < inputHeight)
                         & (col.cast(colType) + (j + offset) >= 0)
                         & (col.cast(colType) + (j + offset) < inputWidth));

                flag.simWatch(String.format("flag_%d_%d", i, j));

                output[i * kernelDim + j] <==
                        flag ? stream.offset(input, streamOffset) : paddedPixels;
            }
        }
    }

    public List<DFEVar> asList() {
        List<DFEVar> l = new ArrayList<DFEVar>();
        for (int i = 0 ; i < output.getSize() ; i++) {
            l.add(output[i]);
        }
        return l;
    }
}
