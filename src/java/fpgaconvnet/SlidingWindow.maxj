package fpgaconvnet;
// package nothing;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;

/* For odd-number sliding windows, the windows are centered around the center pixel:
 * 
 * [ (-2, -2), (-1, -2), (0, -2), (1, -2), (2, -2),
 *   (-2, -1), (-1, -1), (0, -1), (1, -1), (2, -1),
 *   (-2, 0), (-1, 0), (0, 0), (1, 0), (2, 0),
 *   (-2, 1), (-1, 1), (0, 1), (1, 1), (2, 1),
 *   (-2, 2), (-2, 2), (0, 2), (1, 2), (2, 2) ]
 *
 * For even-number sliding windows, the windows are centered around the bottom-right center pixel:
 *
 * [ (-2, -2), (-1, -2), (0, -2), (1, -2)
 *   (-2, -1), (-1, -1), (0, -1), (1, -1)
 *   (-2, 0), (-1, 0), (0, 0), (1, 0)
 *   (-2, 1), (-1, 1), (0, 1), (1, 1) ]
 *
 */

public class SlidingWindow extends KernelLib {
    public final DFEVector<DFEVar> output;
    private final DFEVar row;
    private final DFEVar col;
    private final DFEVar cycle;
    private final CounterChain chain;

    // slides a 2d convolution window
    // around a input stream
    SlidingWindow(
        Kernel argKernel,
        DFEVar input,
        int inputHeight,
        int inputWidth,
        int kernelDim,
        int cyclesToHoldWindow
    ) {
        super(argKernel);
        DFEVectorType<DFEVar> vectorType = new DFEVectorType<DFEVar>(
                input.getType(),
                kernelDim * kernelDim);
        output = vectorType.newInstance(argKernel);

        chain = control.count.makeCounterChain();
        row = Utils.chainCounterOrZero(this, chain, inputHeight);
        col = Utils.chainCounterOrZero(this, chain, inputWidth);
        cycle = Utils.chainCounterOrZero(this, chain, cyclesToHoldWindow);

        for (int i = 0 ; i < kernelDim ; i++) {
            for (int j = 0 ; j < kernelDim ; j++) {
                final int idx = ((i - kernelDim / 2) * inputWidth + (j - kernelDim / 2));
                final int offset = cyclesToHoldWindow * idx;
                final DFEType rowType = dfeInt(
                        Utils.ceilLog2(inputHeight + kernelDim / 2) + 1);
                final DFEType colType = dfeInt(
                        Utils.ceilLog2(inputWidth + kernelDim / 2) + 1);
                final DFEVar flag =
                        ((row.cast(rowType) + (i - kernelDim / 2) >= 0)
                         & (row.cast(rowType) + (i - kernelDim / 2) < inputHeight)
                         & (col.cast(colType) + (j - kernelDim / 2) >= 0)
                         & (col.cast(colType) + (j - kernelDim / 2) < inputWidth));

                output[i * kernelDim + j] <==
                        flag ? stream.offset(input, offset) : 0.0;
            }
        }
    }

    public List<DFEVar> asList() {
        List<DFEVar> l = new ArrayList<DFEVar>();
        for (int i = 0 ; i < output.getSize() ; i++) {
            l.add(output[i]);
        }
        return l;
    }
}
