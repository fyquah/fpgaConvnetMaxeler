package fpgaconvnet;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

import fpgaconvnet.protos.Parameters;


public abstract class ConvolutionKernelBase extends Kernel {
    
    private final Parameters.LayerParameter layerParams;

    public ConvolutionKernelBase (KernelParameters kp, Parameters.LayerParameter argParams) {
        super(kp);
        layerParams = argParams;
    }

    /* The number of cycles to perform _one_ convolution */
    public int getKernelIterations() {
        int kernelDim = layerParams.getConv().getKernelSize();
        return Utils.divCeil(kernelDim * kernelDim, layerParams.getConv().getKernelFoldingFactor());
    }

    /* The number of loop iterations required to convolve a input channel's window with all
     * the the filters that concerned it.
     */
    public int getConvolutionIterations() {
        return Utils.divCeil(
                layerParams.getNumOutputs(), layerParams.getConv().getConvFoldingFactor()); 
    }

    public int getAccumulationIterations() {
        return layerParams.getNumOutputs() / layerParams.getConv().getWorkerFactor();
    }

    /* The number of input channels a worker needs to handle. */
    public int getSchedulerIterations() {
        return Utils.divCeil(layerParams.getNumInputs(), layerParams.getConv().getWorkerFactor());
    }

    public List<Integer> getSchedulerChannels(int workerIndex) {
        List<Integer> ret = new ArrayList<Integer>();
        int workerFactor = layerParams.getConv().getWorkerFactor();
        for (int i = 0 ; i < getSchedulerIterations() ; i++) {
            int channel = (i * workerFactor) + workerIndex;
            if (channel >= layerParams.getNumInputs()) {
                ret.add(-1);
            } else {
                ret.add(channel);
            }
        }
        return ret;
    }

    public static void setDebugMode(boolean flag) {
        debugMode = flag;
    }

    private static boolean debugMode = false;
    protected DFEVar debugFlag() {
        if (debugMode) {
            return constant.var(dfeBool(), 1);
        } else {
            return constant.var(dfeBool(), 0);
        }
    }
}
