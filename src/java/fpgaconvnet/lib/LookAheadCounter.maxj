package fpgaconvnet.lib;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

import fpgaconvnet.IterationCounter;
import fpgaconvnet.Utils;
import fpgaconvnet.kernels.ConvolutionUnitKernel;
import fpgaconvnet.protos.Parameters.LayerParameter;
import fpgaconvnet.protos.Parameters.ConvolutionParameter;


public class LookAheadCounter extends KernelLib {

    private final IterationCounter ctr;
    private final DFEVar lookAhead;
    private final DFEVar weightUsageIter;
    private final DFEVar kernelIter;
    private final int weightsUsageCycles;
    private final LayerParameter layerParams;
    private final ConvolutionParameter convParams;
    private final DFEVar weightAddress;

    public LookAheadCounter(ConvolutionUnitKernel kernel, LayerParameter argLayerParams) {
        super(kernel);
      
        layerParams = argLayerParams;
        convParams = layerParams.getConv();
        ctr = new IterationCounter(layerParams);
        weightsUsageCycles = ctr.getWeightIterations();

        CounterChain chain = control.count.makeCounterChain();
        lookAhead = Utils.chainCounterOrZero(
                this, chain, layerParams.getConv().getLookAhead());
        weightUsageIter = Utils.chainCounterOrZero(this, chain, weightsUsageCycles);
        kernelIter = Utils.chainCounterOrZero(this, chain, ctr.getKernelIterations());

        if (getTotalWeightAddress() <= 1) {
            weightAddress = constant.var(dfeBool(), 0);

        } else {
            weightAddress = control.count.simpleCounter(
                    Utils.ceilLog2(getTotalWeightAddress()),
                    getTotalWeightAddress());

        }
    }

    public DFEVar getWeightsInputFlag() {
        return lookAhead.eq(0);
    }

    public DFEVar getWriteEnable() {
        return lookAhead.eq(0);
    }

    public DFEVar getChannelIter() {
        /* Number of iterations to spend per channel. */
        final int channelIterations = ctr.getConvolutionIterations() * ctr.getKernelIterations();

        DFEVar channelIterBase = control.count.makeCounter(
                control.count.makeParams(Utils.ceilLog2(channelIterations))
                .withInitValue(0l)
                .withInc(weightsUsageCycles * ctr.getKernelIterations())
                .withMax(channelIterations)
                .withEnable(lookAhead.eq(layerParams.getConv().getLookAhead() - 1)
                            & weightUsageIter.eq(weightsUsageCycles - 1)
                            & kernelIter.eq(ctr.getKernelIterations() - 1))
            ).getCount();

        /* Defines the stage at which we are using a particular channel. */
        DFEVar channelIter = dfeUInt(Utils.ceilLog2(channelIterations)).newInstance(this);
        optimization.pushPipeliningFactor(0.0);
        channelIter <== (weightUsageIter.eq(0) & kernelIter.eq(0)
                         ? channelIterBase
                         : modInc(stream.offset(channelIter, -1), channelIterations));
        optimization.popPipeliningFactor();

        return channelIter;
    }

    public DFEVar getInputControlFlag() {
        return getChannelIter().eq(0);
    }

    private DFEVar modInc(DFEVar x, int cap) {
        return (x.eq(cap - 1) ? 0 : x + 1);
    }

    public DFEVar getOutputControlFlag() {
        return constant.var(dfeBool(), 1);
    }

    public DFEVar getPixelWriteEnable() {
        return getChannelIter() < ctr.getKernelIterations();
    }

    public DFEVar getKernelIter() {
        return kernelIter;
    }

    public DFEVar getAddress() {
        return weightAddress;
    }

    public int getTotalWeightAddress() {
        return ctr.getKernelIterations() * weightsUsageCycles;
    }
}
