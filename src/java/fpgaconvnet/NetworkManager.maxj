package fpgaconvnet;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.Scanner;
import java.lang.RuntimeException;

import com.maxeler.maxcompiler.v2.build.EngineParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;
import com.maxeler.maxcompiler.v2.managers.custom.DFELink;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.KernelBlock;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import fpgaconvnet.protos.Parameters;


public class NetworkManager extends CustomManager {

    private Properties prop;
    private List<ConvolutionLayer> convolutionLayers;
    private List<PoolingLayerKernel> poolingKernels;
    private List<KernelBlock> poolingKernelBlocks;
    private DfeInputAlligner inputAllignerKernel;
    private DfeOutputAlligner outputAllignerKernel;
    private KernelBlock inputAllignerBlock, outputAllignerBlock;
    /* NetworkParameters here are completely filled, (ie: earlier stages of the compilation process
     * has populated the parameters appropriately.
     */
    private Parameters.Network networkParameters;

    private static boolean isConvLayer(Parameters.LayerParameter layer) {
        return layer.getParamsCase().equals(Parameters.LayerParameter.ParamsCase.CONV);
    }

    private static boolean isPoolLayer(Parameters.LayerParameter layer) {
        return layer.getParamsCase().equals(Parameters.LayerParameter.ParamsCase.POOL);
    }

    private Dimension inputDimension() {
        Parameters.LayerParameter layer = networkParameters.getLayer(0);
        return new Dimension(layer.getInputHeight(), layer.getInputWidth(), layer.getNumInputs());
    }

    private Dimension outputDimension() {
        Parameters.LayerParameter layer = networkParameters.getLayer(
                networkParameters.getLayerCount() - 1);
        return new Dimension(layer.getOutputHeight(), layer.getOutputWidth(), layer.getNumOutputs());
    }

    public EngineInterface interfaceDefault() {
        EngineInterface ei = new EngineInterface();
        CPUTypes   type = CPUTypes.FLOAT;
        int        size = type.sizeInBytes();
        InterfaceParam  N    = ei.addParam("N", CPUTypes.INT);

        ei.setTicks("DfeInputAlligner", N * inputDimension().totalSize());
        int poolCount = 1;
        int convCount = 1;
        for (int i = 0 ; i < networkParameters.getLayerCount() ; i++) {
            Parameters.LayerParameter layer = networkParameters.getLayer(i);
            if (isConvLayer(layer)) {
                convolutionLayers[convCount-1].setKernelTimings(ei, N);
                convCount++;
            } else if (isPoolLayer(layer)) {
                ei.setTicks("pool" + poolCount, N * poolingKernels[poolCount - 1].cyclesPerImage());
                poolCount++;
            }
        }
        ei.setStream("x", type, N * inputDimension().totalSize() * size);
        ei.setStream("y", type, N * outputDimension().totalSize() * size);

        return ei;
    }

    private void setupKernels() {
        int poolCount = 1;
        inputAllignerKernel = new DfeInputAlligner(
            makeKernelParameters("DfeInputAlligner"), inputDimension().channels());
        for (int i = 0 ; i < networkParameters.getLayerCount() ; i++) {
            Parameters.LayerParameter layer = networkParameters.getLayer(i);
            if (isConvLayer(layer)) {
                convolutionLayers.add(new ConvolutionLayer(layer, this));
            } else if (isPoolLayer(layer)) {
                KernelParameters kernelParameters = makeKernelParameters("pool" + poolCount);
                poolingKernels.add(new PoolingLayerKernel(kernelParameters , layer));
                poolCount++;
            }
        }
        outputAllignerKernel = new DfeOutputAlligner(
            makeKernelParameters("DfeOutputAlligner"), outputDimension().channels());
    }

    private void linkKernels() {
        DFELink cpuInputLink = addStreamFromCPU("x");
        DFELink cpuOutputLink = addStreamToCPU("y");
        int poolingUnitId = 0;
        int convLayerId = 0;

        inputAllignerBlock.getInput("x") <== cpuInputLink;
        DFELink prevOutput = inputAllignerBlock.getOutput("y");
        for (int i = 0 ; i < networkParameters.getLayerCount() ; i++) {
            Parameters.LayerParameter layer = networkParameters.getLayer(i);
            if (isConvLayer(layer)) {
                convolutionLayers[convLayerId].getInput() <== prevOutput;
                prevOutput = convolutionLayers[convLayerId].getOutput();
                convLayerId++;
            } else if (isPoolLayer(layer)) {
                poolingKernelBlocks[poolingUnitId].getInput("x") <== prevOutput;
                prevOutput = poolingKernelBlocks[poolingUnitId].getOutput("y");
                poolingUnitId++;
            }
        }
        outputAllignerBlock.getInput("x") <== prevOutput;
        cpuOutputLink <== outputAllignerBlock.getOutput("y");
    }

    public NetworkManager(EngineParameters engineParameters, Parameters.Network networkParametersIn) {
        super(engineParameters);
        networkParameters = networkParametersIn;
        convolutionLayers = new ArrayList<ConvolutionLayer>();
        poolingKernels = new ArrayList<PoolingLayerKernel>();
        poolingKernelBlocks = new ArrayList<KernelBlock>();

        config.setDefaultStreamClockFrequency(networkParameters.getFrequency());
        System.out.println("Network compilation target:");
        System.out.println(networkParameters.toString());
        setupKernels();
        // TODO(fyq14): Make PoolingLayer class to wrap around the pooling layers kernel too.
        inputAllignerBlock = addKernel(inputAllignerKernel);
        outputAllignerBlock = addKernel(outputAllignerKernel);
        poolingKernelBlocks = new ArrayList<KernelBlock>();
        for (int i = 0 ; i < poolingKernels.size() ; i++) {
            poolingKernelBlocks.add(addKernel(poolingKernels[i]));
        }

        linkKernels();
    }
}
