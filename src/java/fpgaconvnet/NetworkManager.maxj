package fpgaconvnet;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.build.EngineParameters;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;
import com.maxeler.maxcompiler.v2.managers.custom.DFELink;
import com.maxeler.maxcompiler.v2.managers.custom.stdlib.DebugLevel;
import com.maxeler.maxcompiler.v2.managers.custom.stdlib.LMemInterface;
import com.maxeler.maxcompiler.v2.managers.custom.stdlib.LMemCommandGroup;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface.Direction;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import fpgaconvnet.Utils.Tuple3;
import fpgaconvnet.protos.Parameters;


public class NetworkManager extends CustomManager {

    private LMemInterface lmem;
    private List<ComputationChain> computationChains;
    /* NetworkParameters here are completely filled, (ie: earlier stages of the compilation process
     * has populated the parameters appropriately.
     */
    private Parameters.Network networkParameters;

    private static boolean isConvLayer(Parameters.LayerParameter layer) {
        return layer.getParamsCase().equals(Parameters.LayerParameter.ParamsCase.CONV);
    }

    private static boolean isPoolLayer(Parameters.LayerParameter layer) {
        return layer.getParamsCase().equals(Parameters.LayerParameter.ParamsCase.POOL);
    }

    private static boolean isLrnLayer(Parameters.LayerParameter layer) {
        return layer.getParamsCase().equals(Parameters.LayerParameter.ParamsCase.LRN);
    }

    private static EngineInterface interfaceWrite(String name) {
        EngineInterface ei = new EngineInterface(name);
        InterfaceParam start = ei.addParam("start", CPUTypes.UINT64);
        InterfaceParam size = ei.addParam("size", CPUTypes.UINT64);
        InterfaceParam sizeInBytes = size;

        ei.setStream("weights_in", CPUTypes.FLOAT, sizeInBytes);
        ei.setLMemLinear("cpu2lmem", start, sizeInBytes);
        ei.ignoreAll(Direction.IN_OUT);
        return ei;
    }

    private EngineInterface interfaceDefault () {
        EngineInterface ei = new EngineInterface();

        InterfaceParam N = ei.addParam("N", CPUTypes.UINT64);
        InterfaceParam init = ei.addParam("init", CPUTypes.UINT8);

        for (int i = 0 ; i < computationChains.size() ; i++) {
            computationChains[i].setKernelTimings(ei, N, init);
        }

        Parameters.LayerParameter firstLayer = networkParameters.getLayer(0);
        Parameters.LayerParameter lastLayer = networkParameters.getLayer(
                networkParameters.getLayerCount() - 1);
        int inputSize = Utils.layerInputDimension(firstLayer).totalSize();
        int outputSize = Utils.layerOutputDimension(lastLayer).totalSize();

        ei.setStream("fromcpu", CPUTypes.FLOAT, N * inputSize * CPUTypes.FLOAT.sizeInBytes());
        ei.setStream("tocpu", CPUTypes.FLOAT, N * outputSize * CPUTypes.FLOAT.sizeInBytes());

        // configuring streams for ConvolutionLayers.
        for (int i = 0 ; i < networkParameters.getLayerCount() ; i++) {
            Parameters.LayerParameter layerParams = networkParameters.getLayer(i);

            if (isConvLayer(layerParams)) {
                computationChains[i].setScalar(ei, "init", init);
                for (Tuple3<String, DFELink, Integer> link : computationChains[i].getInitializerInputs()) {
                    ei.setStream(
                            link.getFirst(),
                            CPUTypes.FLOAT,
                            init ? link.getThird() * CPUTypes.FLOAT.sizeInBytes() : 0);
                }
                for (Tuple3<String, DFELink, Integer> link : computationChains[i].getLMemInputs()) {
                    /* Third is stream size perPixel */
                    int arrSize = link.getThird() * CPUTypes.FLOAT.sizeInBytes();
                    InterfaceParam rwSize =
                            layerParams.getOutputHeight() * layerParams.getOutputWidth()
                            / layerParams.getConv().getLookAhead()
                            * N * arrSize;
                    // ei.setLMemLinear(
                    //         link.getFirst(),
                    //         ei.addConstant(0l),
                    //         rwSize);
                    ei.setLMemLinearWrapped(
                            link.getFirst(),                       /* streamName */
                            ei.addConstant(0l),                    /* address */
                            ei.addConstant(arrSize), /* arrSize */
                            rwSize,                   /* rwSize */
                            ei.addConstant(0l)                     /* offset */
                    );
                }

            } else if (isLrnLayer(layerParams)) {
                InterfaceParam approx_factor = ei.addParam(
                        "approx_factor_" + layerParams.getLayerId(), CPUTypes.FLOAT);
                computationChains[i].setScalar(ei, "approx_factor", approx_factor);

            }
        }

        ei.ignoreAll(Direction.IN_OUT);
        return ei;
    }

    private void setupKernels() {
        for (int i = 0 ; i < networkParameters.getLayerCount() ; i++) {
            Parameters.LayerParameter layer = networkParameters.getLayer(i);
            if (isConvLayer(layer)) {
                computationChains.add(new ConvolutionLayer(layer, this));
            } else if (isPoolLayer(layer)) {
                computationChains.add(new PoolingLayer(layer, this));
            } else if (isLrnLayer(layer)) {
                computationChains.add(new LrnLayer(layer, this));
            } else {
                throw new RuntimeException("Unknown layer!");
            }
        }
    }

    private void linkKernels() {

        /* Weights initialization. */
        DFELink cpu2lmem = lmem.addStreamToLMem(
                "cpu2lmem", LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
        DFELink weightsFromCpu = addStreamFromCPU("weights_in");
        cpu2lmem <== weightsFromCpu;

        /* Data tranfer */
        DFELink fromCpu = addStreamFromCPU("fromcpu");
        DFELink toCpu = addStreamToCPU("tocpu");

        /* Kernel logic transfer */
        DFELink prevOutput = fromCpu;

        for (int i = 0 ; i < networkParameters.getLayerCount() ; i++) {
            computationChains[i].getInput() <== prevOutput;
            prevOutput = computationChains[i].getOutput();
        }
        toCpu <== prevOutput;

        /* Weight initialization. */
        for (int i = 0 ; i < networkParameters.getLayerCount() ; i++) {
            for (Tuple3<String, DFELink, Integer> link : computationChains[i].getInitializerInputs()) {
                DFELink dataStream = addStreamFromCPU(link.getFirst());
                link.getSecond() <== dataStream;
            }

            for (Tuple3<String, DFELink, Integer> link : computationChains[i].getLMemInputs()) {
                DFELink dataStream = lmem.addStreamFromLMem(
                        link.getFirst(),
                        LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
                link.getSecond() <== dataStream;
            }
        }
    }

    public NetworkManager(EngineParameters engineParameters, Parameters.Network networkParametersIn) {
        super(engineParameters);
        networkParameters = networkParametersIn;
        computationChains = new ArrayList<ComputationChain>();
        lmem = addLMemInterface();

        config.setAllowNonMultipleTransitions(true);
        debug.setDebugLevel(new DebugLevel().setHasStreamStatus(true));
        config.setDefaultStreamClockFrequency(networkParameters.getFrequency());
        System.out.println("Network compilation target:");
        System.out.println(networkParameters.toString());
        System.out.println("Frequency = " + networkParameters.getFrequency());

        setupKernels();
        linkKernels();

        /* Interfaces */
        createSLiCinterface(interfaceDefault());
        createSLiCinterface(interfaceWrite("writeLMem"));
    }
}
