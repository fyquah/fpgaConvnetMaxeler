package fpgaconvnet;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.Scanner;
import java.lang.RuntimeException;

import com.maxeler.maxcompiler.v2.build.EngineParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;
import com.maxeler.maxcompiler.v2.managers.custom.DFELink;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.KernelBlock;
import com.maxeler.maxcompiler.v2.managers.custom.stdlib.LMemInterface;
import com.maxeler.maxcompiler.v2.managers.custom.stdlib.MemoryControlGroup;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface.Direction;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParamArray;

import fpgaconvnet.protos.Parameters;
import fpgaconvnet.protos.Parameters.LayerParameter;


public class NetworkManager extends CustomManager {

    private Properties prop;
    private List<ConvolutionLayer> convolutionLayers;
    private List<PoolingLayerKernel> poolingKernels;
    private List<KernelBlock> poolingKernelBlocks;
    /* NetworkParameters here are completely filled, (ie: earlier stages of the compilation process
     * has populated the parameters appropriately.
     */
    private Parameters.Network networkParameters;

    private static boolean isConvLayer(Parameters.LayerParameter layer) {
        return layer.getParamsCase().equals(Parameters.LayerParameter.ParamsCase.CONV);
    }

    private static boolean isPoolLayer(Parameters.LayerParameter layer) {
        return layer.getParamsCase().equals(Parameters.LayerParameter.ParamsCase.POOL);
    }

    private Dimension inputDimension() {
        Parameters.LayerParameter layer = networkParameters.getLayer(0);
        return new Dimension(layer.getInputHeight(), layer.getInputWidth(), layer.getNumInputs());
    }

    private Dimension outputDimension() {
        Parameters.LayerParameter layer = networkParameters.getLayer(
                networkParameters.getLayerCount() - 1);
        return new Dimension(layer.getOutputHeight(), layer.getOutputWidth(), layer.getNumOutputs());
    }

    private EngineInterface interfaceDefault () {
        EngineInterface ei = new EngineInterface();

        InterfaceParam N = ei.addParam("N", CPUTypes.UINT64);
        InterfaceParam addr_images = ei.addParam("address_images", CPUTypes.UINT64);
        InterfaceParam addr_features = ei.addParam("address_features", CPUTypes.UINT64);

        for (int i = 0 ; i < convolutionLayers.size() ; i++) {
            convolutionLayers[i].setKernelTimings(ei, N);
        }
        for (int i = 0; i < poolingKernels.size() ; i++) {
            ei.setTicks(poolingKernels[i].getName(), N * poolingKernels[i].cyclesPerImage());
        }

        Parameters.LayerParameter firstLayer = networkParameters.getLayer(0);
        Parameters.LayerParameter lastLayer = networkParameters.getLayer(
                networkParameters.getLayerCount() - 1);
        int inputSize = Utils.layerInputDimension(firstLayer).totalSize();
        int outputSize = Utils.layerOutputDimension(lastLayer).totalSize();

        ei.setLMemLinear("images", addr_images, N * inputSize * CPUTypes.FLOAT.sizeInBytes());
        ei.setLMemLinear("features", addr_features, N * outputSize * CPUTypes.FLOAT.sizeInBytes());
        ei.ignoreAll(Direction.IN_OUT);
        return ei;
    }

    private void ignoreConvFMem(EngineInterface ei, Parameters.LayerParameter layer, int layerId) {
        final String kernelName = String.format("ConvolutionUnit_%d", layerId);

        for (int worker = 0 ; worker < layer.getConv().getWorkerFactor(); worker++) {
            for (int convUnit = 0; convUnit < layer.getConv().getConvFoldingFactor(); convUnit++) {
                for (int multId = 0; multId < layer.getConv().getKernelFoldingFactor(); multId++) {
                    String memName = String.format("kernels_%d_%d_%d", worker, convUnit, multId);
                    ei.ignoreMem(kernelName, memName, Direction.IN);
                }
            }
        }
        ei.ignoreMem(String.format("ConvolutionAccumulator_%d", layerId), "bias", Direction.IN);
    }

    private EngineInterface ignoreMem(EngineInterface ei) {
        for (int i = 0 ; i < networkParameters.getLayerCount() ; i++) {
            Parameters.LayerParameter layer = networkParameters.getLayer(i);
            if (isConvLayer(layer)) {
                ignoreConvFMem(ei, layer, i);
            }
        }
        return ei;
    }

    private EngineInterface buildLoadDataInterface() {
        EngineInterface ei = new EngineInterface("load_data");
        CPUTypes type = CPUTypes.FLOAT;
        InterfaceParam address = ei.addParam("address", CPUTypes.UINT64);
        InterfaceParam size = ei.addParam("size", CPUTypes.UINT64);
        InterfaceParam sizeInBytes = size * type.sizeInBytes();

        ei.setStream("fromcpu", type, sizeInBytes);
        ei.setLMemLinear("cpu2lmem", address, sizeInBytes);
        ei.ignoreAll(Direction.IN_OUT);
        return ei;
    }

    private EngineInterface buildGetResultsInterface() {
        EngineInterface ei = new EngineInterface("get_results");
        CPUTypes type = CPUTypes.FLOAT;
        InterfaceParam address = ei.addParam("address", CPUTypes.UINT64);
        InterfaceParam size = ei.addParam("size", CPUTypes.UINT64);
        InterfaceParam sizeInBytes = size * type.sizeInBytes();

        ei.setLMemLinear("lmem2cpu", address, sizeInBytes);
        ei.setStream("tocpu", type, sizeInBytes);
        ei.ignoreAll(Direction.IN_OUT);
        return ei;
    }

    private void initSingleConvRom(
            EngineInterface ei,
            Parameters.LayerParameter layer,
            int worker, int convUnit, int multId) {

        String blockName = String.format("ConvolutionUnit_%d", layer.getLayerId());
        String memoryName = String.format("kernels_%d_%d_%d", worker, convUnit, multId);
        String paramName = String.format("layer_%d_%s", layer.getLayerId(), memoryName);
        InterfaceParamArray paramArray = ei.addParamArray(paramName, CPUTypes.DOUBLE);
        final int arraySize = new IterationCounter(layer).getTotalIterations();

        ei.setMem(blockName, memoryName, 0, arraySize, paramArray);
    }

    private void initConvLayer(EngineInterface ei, Parameters.LayerParameter layer) {

        final int workerFactor = layer.getConv().getWorkerFactor();
        final int totalWeights =
                layer.getNumOutputs() * layer.getNumInputs()
                * layer.getConv().getKernelSize() * layer.getConv().getKernelSize();

        for (int worker = 0 ; worker < layer.getConv().getWorkerFactor(); worker++) {
            for (int convUnit = 0; convUnit < layer.getConv().getConvFoldingFactor(); convUnit++) {
                for (int multId = 0; multId < layer.getConv().getKernelFoldingFactor(); multId++) {
                    initSingleConvRom(ei, layer, worker, convUnit, multId);
                }
            }
        }

        String paramName = String.format("bias_%d", layer.getLayerId());
        InterfaceParamArray paramArray = ei.addParamArray(paramName, CPUTypes.DOUBLE);
        String name = String.format("ConvolutionAccumulator_%d", layer.getLayerId());

        for (int j = 0 ; j < layer.getNumOutputs() ; j++) {
            ei.setMem(name, "bias", j, paramArray[j]);
        }
    }

    private EngineInterface buildInitInterface() {
        EngineInterface ei = new EngineInterface("init_convnet");

        for (int i = 0 ; i < networkParameters.getLayerCount() ; i++) {
            Parameters.LayerParameter layer = networkParameters.getLayer(i);
            if (isConvLayer(layer)) {
                initConvLayer(ei, layer);
            }
        }

        ei.ignoreAll(Direction.IN_OUT);
        return ei;
    }

    private void setupKernels() {
        for (int i = 0 ; i < networkParameters.getLayerCount() ; i++) {
            Parameters.LayerParameter layer = networkParameters.getLayer(i);
            if (isConvLayer(layer)) {
                convolutionLayers.add(new ConvolutionLayer(layer, this));
            } else if (isPoolLayer(layer)) {
                KernelParameters kernelParameters = makeKernelParameters("pool" + i);
                poolingKernels.add(new PoolingLayerKernel(kernelParameters , layer));
            }
        }
    }

    private void linkKernels() {

        /* Data tranfer */
        DFELink fromCpu = addStreamFromCPU("fromcpu");
        DFELink toCpu = addStreamToCPU("tocpu");
        DFELink cpu2lmem = addStreamToOnCardMemory("cpu2lmem", MemoryControlGroup.MemoryAccessPattern.LINEAR_1D);
        DFELink lmem2cpu = addStreamFromOnCardMemory("lmem2cpu", MemoryControlGroup.MemoryAccessPattern.LINEAR_1D);

        cpu2lmem <== fromCpu;
        toCpu <== lmem2cpu;

        /* Kernel logic transfer */
        DFELink lmemInputLink = addStreamFromOnCardMemory("images", MemoryControlGroup.MemoryAccessPattern.LINEAR_1D);
        DFELink lmemOutputLink = addStreamToOnCardMemory("features", MemoryControlGroup.MemoryAccessPattern.LINEAR_1D);
        int poolingUnitId = 0;
        int convLayerId = 0;

        DFELink prevOutput = lmemInputLink;

        for (int i = 0 ; i < networkParameters.getLayerCount() ; i++) {
            Parameters.LayerParameter layer = networkParameters.getLayer(i);
            if (isConvLayer(layer)) {
                convolutionLayers[convLayerId].getInput() <== prevOutput;
                prevOutput = convolutionLayers[convLayerId].getOutput();
                convLayerId++;
            } else if (isPoolLayer(layer)) {
                poolingKernelBlocks[poolingUnitId].getInput("x") <== prevOutput;
                prevOutput = poolingKernelBlocks[poolingUnitId].getOutput("y");
                poolingUnitId++;
            }
        }
        lmemOutputLink <== prevOutput;
    }

    public NetworkManager(EngineParameters engineParameters, Parameters.Network networkParametersIn) {
        super(engineParameters);
        networkParameters = networkParametersIn;
        convolutionLayers = new ArrayList<ConvolutionLayer>();
        poolingKernels = new ArrayList<PoolingLayerKernel>();
        poolingKernelBlocks = new ArrayList<KernelBlock>();

        config.setAllowNonMultipleTransitions(true);
        config.setDefaultStreamClockFrequency(networkParameters.getFrequency());
        System.out.println("Network compilation target:");
        System.out.println(networkParameters.toString());
        System.out.println("Frequency = " + networkParameters.getFrequency());
        setupKernels();

        // TODO(fyq14): Make PoolingLayer class to wrap around the pooling layers kernel too.
        poolingKernelBlocks = new ArrayList<KernelBlock>();
        for (int i = 0 ; i < poolingKernels.size() ; i++) {
            poolingKernelBlocks.add(addKernel(poolingKernels[i]));
        }
        linkKernels();

        /* Interfaces */
        createSLiCinterface(buildInitInterface());
        createSLiCinterface(buildLoadDataInterface());
        createSLiCinterface(interfaceDefault());
        createSLiCinterface(buildGetResultsInterface());
    }
}
