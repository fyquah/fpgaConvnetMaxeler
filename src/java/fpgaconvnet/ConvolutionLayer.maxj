package fpgaconvnet;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.managers.custom.DFELink;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import fpgaconvnet.protos.Parameters.LayerParameter;
import fpgaconvnet.protos.Parameters.ConvolutionParameter;
import fpgaconvnet.kernels.ConvolutionSchedulerKernel;
import fpgaconvnet.kernels.ConvolutionAccumulatorKernel;
import fpgaconvnet.kernels.ConvolutionUnitKernel;
import fpgaconvnet.kernels.ConvolutionUnitKernel.WeightsLoadStrategy;
import fpgaconvnet.Utils.Tuple3;


public class ConvolutionLayer implements ComputationChain {
    private final LayerParameter layer;
    private final ConvolutionParameter convParams;
    private final CustomManager manager;
    private final BoxedKernelBlock<ConvolutionSchedulerKernel> scheduler;
    private final BoxedKernelBlock<ConvolutionUnitKernel> convolutionUnit;
    private final BoxedKernelBlock<ConvolutionAccumulatorKernel> accumulator;
    
    ConvolutionLayer(LayerParameter argLayer, CustomManager argManager) {
        layer = argLayer;
        convParams = layer.getConv();
        manager = argManager;

        scheduler = new BoxedKernelBlock<ConvolutionSchedulerKernel>(
                manager,
                new ConvolutionSchedulerKernel(
                        manager.makeKernelParameters("ConvolutionScheduler_" + layer.getLayerId()),
                                                     layer));
        accumulator = new BoxedKernelBlock<ConvolutionAccumulatorKernel>(
                manager,
                new ConvolutionAccumulatorKernel(
                        manager.makeKernelParameters(
                            "ConvolutionAccumulator_" + layer.getLayerId()),
                        layer));

        convolutionUnit = new BoxedKernelBlock<ConvolutionUnitKernel>(
                manager,
                new ConvolutionUnitKernel(
                        manager.makeKernelParameters(
                            String.format("ConvolutionUnit_%d", layer.getLayerId())),
                        layer));

        joinKernels();
    }

    public DFELink getInput() {
        return scheduler.getBlock().getInput(scheduler.getKernel().getInputName());
    }

    public DFELink getOutput() {
        return accumulator.getBlock().getOutput(accumulator.getKernel().getOutputName());
    }

    public void setKernelTimings(EngineInterface ei, InterfaceParam numberOfImages, InterfaceParam init) {
        /*
         * scheduler and convolution units do not have a loop offset, so we will not
         * need to deal with ei.getAutoLoopOffset.
         */
        ei.setTicks(scheduler.getKernel().getName(),
                    numberOfImages * scheduler.getKernel().cyclesPerImage());

        ei.setTicks(convolutionUnit.getKernel().getName(),
                    numberOfImages * convolutionUnit.getKernel().cyclesPerImage()
                    + (init ? convolutionUnit.getKernel().initCycles() : 0));

        /* Accumulator */
        InterfaceParam latency = ei.getAutoLoopOffset(
                accumulator.getKernel().getName(),
                accumulator.getKernel().getOffsetExprName());
        ei.ignoreAutoLoopOffset(accumulator.getKernel().getName(),
                                accumulator.getKernel().getOffsetExprName());
        ei.setTicks(accumulator.getKernel().getName(),
                    numberOfImages * accumulator.getKernel().cyclesPerImage() * latency
                    + (init ? accumulator.getKernel().initCycles() : 0));
    }

    /*
     * Connects the convolution internal stuff. Meant to be used by the constructor.
     */
    protected void joinKernels() {

        /* Configure from scheduler -> convolutionUnits */
        for (int i = 0 ; i < layer.getConv().getWorkerFactor() ; i++) {
            DFELink pixelsFrom = scheduler.getBlock().getOutput(
                        scheduler.getKernel().getOutputName(i));
            DFELink pixelsTo = convolutionUnit.getBlock().getInput(
                        convolutionUnit.getKernel().getInputName(i));

            pixelsTo <== pixelsFrom;
        }

        /* Configure from convolutionUnits -> accumulator */
        for (int i = 0 ; i < layer.getConv().getWorkerFactor() ; i++) {
            DFELink from = convolutionUnit.getBlock()
                    .getOutput(convolutionUnit.getKernel().getOutputName(i));
            DFELink to = accumulator.getBlock()
                    .getInput(accumulator.getKernel().getInputName(i));

            to <== from;
        }
    }

    public void setScalar(EngineInterface ei, String name, InterfaceParam param) {
        if (name.equals("init")) {
            if (convolutionUnit.getKernel().getWeightsLoadStrategy()
                    == WeightsLoadStrategy.INIT_FROM_CPU) {
                ei.setScalar(convolutionUnit.getKernel().getName(), "init", param);
            }
        } else {
            ei.setScalar(convolutionUnit.getKernel().getName(), name, param);
        }
        ei.setScalar(accumulator.getKernel().getName(), name, param);
    }

    public List<Tuple3<String, DFELink, Integer>> getInitializerInputs() {
        ArrayList<Tuple3<String, DFELink, Integer>> ret = new ArrayList<Tuple3<String, DFELink, Integer>>();
        if (convolutionUnit.getKernel().getWeightsLoadStrategy()
                == WeightsLoadStrategy.INIT_FROM_CPU) {
            ret.add(new Tuple3<String, DFELink, Integer>(
                    String.format("kernel_%d", layer.getLayerId()),
                    convolutionUnit.getBlock().getInput(
                        convolutionUnit.getKernel().getCpuWeightsInputName()),
                    convolutionUnit.getKernel().initStreamSize()));
        }
        ret.add(new Tuple3<String, DFELink, Integer>(
                String.format("bias_%d", layer.getLayerId()),
                accumulator.getBlock().getInput(
                    accumulator.getKernel().getBiasInputName()),
                accumulator.getKernel().initCycles()));
        return ret;
    }

    public List<Tuple3<String, DFELink, Integer>> getLMemInputs() {
        ArrayList<Tuple3<String, DFELink, Integer>> ret =
                new ArrayList<Tuple3<String, DFELink, Integer>>();

        if (convolutionUnit.getKernel().getWeightsLoadStrategy()
                == WeightsLoadStrategy.INIT_FROM_CPU) {
            return ret;
        }

        for (int worker = 0; worker < convParams.getWorkerFactor() ; worker++) {
            for (int conv = 0 ; conv < convParams.getConvFoldingFactor() ; conv++) {
                for (int mult = 0 ; mult < convParams.getKernelFoldingFactor(); mult++) {
                    ret.add(new Tuple3<String, DFELink, Integer>(
                                convolutionUnit.getKernel().getLMemWeightName(worker, conv, mult),
                                convolutionUnit.getBlock().getInput(
                                    convolutionUnit.getKernel().getLMemWeightName(worker, conv, mult)),
                                convolutionUnit.getKernel().lmemStreamSizePerImage()));
                }
            }
        }

        return ret;
    }

    public BoxedKernelBlock<ConvolutionSchedulerKernel> getScheduler()
    {
        return scheduler;
    }

    public BoxedKernelBlock<ConvolutionUnitKernel> getConvolutionUnit()
    {
        return convolutionUnit;
    }

    public BoxedKernelBlock<ConvolutionAccumulatorKernel> getAccumulator()
    {
        return accumulator;
    }
}
