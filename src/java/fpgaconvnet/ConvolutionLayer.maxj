package fpgaconvnet;

import java.util.List;
import java.util.ArrayList;

import com.maxeler.maxcompiler.v2.managers.custom.DFELink;
import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.KernelBlock;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import fpgaconvnet.protos.Parameters.ConvolutionParameter;
import fpgaconvnet.protos.Parameters.LayerParameter;


public class ConvolutionLayer {
    private final LayerParameter layer;
    private final CustomManager manager;
    private final BoxedKernelBlock<ConvolutionSchedulerKernel> scheduler;
    private final BoxedKernelBlock<ConvolutionUnitKernel> convolutionUnit;
    private final BoxedKernelBlock<ConvolutionAccumulatorKernel> accumulator;
    
    ConvolutionLayer(LayerParameter argLayer, CustomManager argManager) {
        layer = argLayer;
        manager = argManager;

        scheduler = new BoxedKernelBlock<ConvolutionSchedulerKernel>(
                new ConvolutionSchedulerKernel(
                        manager.makeKernelParameters("ConvolutionScheduler_" + layer.getLayerId()),
                                                     layer));
        accumulator = new BoxedKernelBlock<ConvolutionAccumulatorKernel>(
                new ConvolutionAccumulatorKernel(
                        manager.makeKernelParameters(
                            "ConvolutionAccumulator_" + layer.getLayerId()),
                        layer));

        convolutionUnit = new BoxedKernelBlock<ConvolutionUnitKernel>(
                new ConvolutionUnitKernel(
                        manager.makeKernelParameters(
                            String.format("ConvolutionUnit_%d", layer.getLayerId())),
                        layer));

        joinKernels();
    }

    public DFELink getInput() {
        return scheduler.getBlock().getInput(
                scheduler.getKernel().getInputName());
    }

    public DFELink getOutput() {
        return accumulator.getBlock().getOutput(accumulator.getKernel().getOutputName());
    }

    // TODO(fyq14): Once pipelining is introduced, this function probably needs some
    //              rewriting w.r.t. the cycles required.
    protected void setKernelTimings(EngineInterface ei, InterfaceParam numberOfImages) {
        /*
         * scheduler and convolution units do not have a loop offset, so we will not
         * need to deal with ei.getAutoLoopOffset.
         */
        ei.setTicks(scheduler.getKernel().getName(),
                    numberOfImages * scheduler.getKernel().cyclesPerImage());

        ei.setTicks(convolutionUnit.getKernel().getName(),
                    numberOfImages * convolutionUnit.getKernel().cyclesPerImage());

        /* Accumulator */
        // InterfaceParam latency = ei.getAutoLoopOffset(
        //         accumulator.getKernel().getName(),
        //         accumulator.getKernel().getOffsetExprName());
        // ei.ignoreAutoLoopOffset(accumulator.getKernel().getName(),
        //                         accumulator.getKernel().getOffsetExprName());
        ei.setTicks(accumulator.getKernel().getName(),
                    numberOfImages * accumulator.getKernel().cyclesPerImage());
    }

    /*
     * Connects the convolution internal stuff. Meant to be used by the constructor.
     */
    protected void joinKernels() {

        /* Configure from scheduler -> convolutionUnits */
        for (int i = 0 ; i < layer.getConv().getWorkerFactor() ; i++) {
            DFELink pixelsFrom = scheduler.getBlock().getOutput(
                        scheduler.getKernel().getOutputName(i));
            DFELink pixelsTo = convolutionUnit.getBlock().getInput(
                        convolutionUnit.getKernel().getInputName(i));

            pixelsTo <== pixelsFrom;
        }

        /* Configure from convolutionUnits -> accumulator */
        for (int i = 0 ; i < layer.getConv().getWorkerFactor() ; i++) {
            DFELink from = convolutionUnit.getBlock()
                    .getOutput(convolutionUnit.getKernel().getOutputName(i));
            DFELink to = accumulator.getBlock()
                    .getInput(accumulator.getKernel().getInputName(i));

            to <== from;
        }
    }

    public class BoxedKernelBlock<T extends Kernel> {
        private final KernelBlock block;
        private final T kernel;

        BoxedKernelBlock(T argKernel) {
            kernel = argKernel;
            block = manager.addKernel(kernel);
        }

        public T getKernel() {
            return kernel;
        }

        public KernelBlock getBlock() {
            return block;
        }
    }
}
