import org.junit.Test;
import static org.junit.Assert.*;
import org.junit.runner.Result;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.managers.standard.SimulationManager;
import com.maxeler.maxcompiler.v2.utils.Bits;

public class TestConvolutionLayerKernel {

    // ---------------------------
    // various utilities to do convolution tests ...
    // ---------------------------

    public static float rand() {
        return (float) (((Math.random() - 0.5) * 1));
    }

    public static float[][] randomKernel(int kernelDim) {
        float[][] ret = new float[kernelDim][kernelDim];

        for (int i = 0;  i < kernelDim ; i++) {
            for (int j = 0 ; j < kernelDim ; j++) {
                ret[i][j] = rand();
            }
        }

        return ret;
    }

    public static ArrayList<Float> generateRandomBias(int outputChannels) {
        ArrayList<Float> ret = new ArrayList<Float>();

        for (int i = 0 ; i < outputChannels; i++) {
            ret.add(rand());
        }

        return ret;
    }

    public static ArrayList<ArrayList<float[][]>> generateRandomKernels(
            Dimension inputDim, int kernelDim, int outputChannels) {
        ArrayList<ArrayList<float[][]>> ret = new ArrayList<ArrayList<float[][]>>();

        for (int i = 0 ; i < outputChannels ; i++) {
            ret.add(new ArrayList<float[][]>());
            for (int j = 0 ; j < inputDim.channels() ; j++) {
                ret[i].add(randomKernel(kernelDim));
            }
        }

        return ret;
    }

    public static ArrayList<Double> generateRandomData(Dimension dim) {
        ArrayList<Double> ret = new ArrayList<Double>();

        for (int i = 0 ; i < dim.height() ; i++) {
            for (int j = 0 ; j < dim.width() ; j++) {
                for (int k = 0 ; k < dim.channels() ; k++) {
                    ret.add((double) rand());
                }
            }
        }

        return ret;
    }


    public static double convolve(
            ArrayList<Double> inputData,
            Dimension inputDimension,
            int centreRow, int centreCol, int chan,
            float[][] kernel) {

        int kernelDim = kernel.length;
        int height = inputDimension.height();
        int width = inputDimension.width();
        int channels = inputDimension.channels();
        double ret = 0.0;

        for (int i = -(kernelDim / 2) ; i <= kernelDim / 2 ; i++) {
            for (int j = -(kernelDim / 2) ; j <= kernelDim / 2 ; j++) {
                int r = centreRow + i;
                int c = centreCol + j;

                ret += kernel[i+(kernelDim / 2)][j +(kernelDim/2)] *
                    inputData[r * (width * channels) + c * channels + chan];
            }
        }

        return ret;
    }

    public static ArrayList<Double> computeExpected(
            ArrayList<Double> input,
            Dimension inputDimension,
            ArrayList<ArrayList<float[][]>> kernels,
            ArrayList<Float> bias) {

        int inputHeight = inputDimension.height();
        int inputWidth = inputDimension.width();
        int inputChannels = inputDimension.channels();
        int outputChannels = kernels.size();
        int kernelDim = kernels[0][0].length;
        ArrayList<Double> ret = new ArrayList<Double>();

        for (int r = 0 ; r < inputHeight ; r++) {
            for (int c = 0 ; c < inputWidth ; c++) {
                if (r < kernelDim / 2 || c < kernelDim / 2 ||
                        r > inputHeight - 1 - kernelDim / 2  ||
                        c > inputWidth - 1 - kernelDim / 2) {
                    continue;
                }

                for (int o = 0 ; o < outputChannels ; o++) {
                    float x = 0.0f;
                    for (int i = 0 ; i < inputChannels ; i++) {
                        float[][] kernel = kernels.get(o).get(i);
                        x += convolve(input, inputDimension, r, c, i, kernel);
                    }
                    x += bias[o];

                    ret.add((double) x);
                }
            }
        }

        return ret;
    }

    // ---------------------------
    // test for resource bench
    // ---------------------------

    public static class RB {
        public static ArrayList<Double> loadSampleData(String filename, 
               int height, int width, int totalChannels) {
            ArrayList<Double> ret = new ArrayList<Double>();

            try {
                Scanner in = new Scanner(new FileInputStream(filename));
                for (int r = 0; r < height ; r++) {
                    for (int c = 0 ; c < width ; c++) {
                        for (int i = 0 ;i < totalChannels ; i++) {
                            ret.add((double) in.nextFloat());
                        }
                    }
                }
                in.close();

            } catch (FileNotFoundException e) {
                e.printStackTrace();
                System.exit(1);
            }


            return ret;
        }
        public static ArrayList<Float> loadConvolutionBiases() {
            final int outputChannels = 20;
            ArrayList<Float> ret = new ArrayList<Float>();

            String filename = "../resource_benchmark/convolution_kernels/bias.txt";
            try {
                Scanner in = new Scanner(new FileInputStream(filename));

                for (int i = 0 ; i < outputChannels ; i++) {
                    ret.add(in.nextFloat());
                }

                in.close();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
                System.exit(1);
            }

            return ret;
        }

        public static ArrayList<ArrayList<float[][]>> loadConvolutionKernels() {
            ArrayList<ArrayList<float[][]>> ret = new ArrayList<ArrayList<float[][]>>();

            final int inputChannels = 10;
            final int outputChannels = 20;
            final int inputHeight = 28;
            final int inputWidth = 28;
            final int kernelDim = 5;

            for (int o = 0 ; o < outputChannels ; o++) {
                ArrayList<float[][]> l = new ArrayList<float[][]>();

                for (int i = 0 ; i < inputChannels ; i++) {
                    float mat[][] = new float[kernelDim][kernelDim];
                    String filename = "../resource_benchmark/convolution_kernels/mat_" +
                        Integer.toString(o) + "_" +
                        Integer.toString(i) + ".txt";

                    try {
                        Scanner in = new Scanner(new FileInputStream(filename));
                        for (int r = 0 ; r < kernelDim ; r++) {
                            for (int c = 0 ; c < kernelDim ; c++) {
                                mat[r][c] = in.nextFloat();
                            }
                        }
                        in.close();
                        l.add(mat);
                    } catch (FileNotFoundException e) {
                        e.printStackTrace();
                        System.exit(1);
                    }
                }

                ret.add(l);
            }

            return ret;
        }

        public static ArrayList<Double> loadInputData(int id) {

            String filename = "../resource_benchmark/inputs/input_" +
                Integer.toString(id) + ".txt";
            return loadSampleData(filename, 28, 28, 10);
        }

        public static ArrayList<Double> loadOutputData(int id) {
            String filename = "../resource_benchmark/outputs/output_" +
                Integer.toString(id) + ".txt";
            return loadSampleData(filename,
                    28 - (5 - 1),
                    28 - (5 - 1),
                    20);
        }
    }

    public ArrayList<Bits> toBitsInput (ArrayList<Double> input, int inputChannels) {
        ArrayList<Bits> ret = new ArrayList<Bits>();

        for (int i = 0 ; i < input.size() / inputChannels ; i++) {
            Bits[] bitsArr = new Bits[inputChannels];

            for (int j = 0 ; j < inputChannels ; j++) {
                int idx = i * inputChannels + j;
                bitsArr[j] = Utils.doubleToBits(input[idx]);
            }

            ret.add(Utils.concatBits(bitsArr));
        }

        return ret;
    }

    public List<Double> toDoubleOutput(List<Bits> output, int outputChannels) {
        ArrayList<Double> ret = new ArrayList<Double>();

        for (int i = 0 ; i < output.size() ; i++) {
            for (int j = 0 ; j < outputChannels ; j++) {
                int totalBits = GlobalConfig.intBits + GlobalConfig.fracBits;
                Bits b = Utils.subBits(output[i], j * totalBits, totalBits);
                ret.add(Utils.bitsToDouble(b));
            }
        }

        return ret;
    }

    @Test
    public void testLargeConvolution() {
        final int inputHeight = 28;
        final int inputWidth = 28;
        final int inputChannels = 20;
        final int outputChannels = 50;
        final int kernelDim = 5;

        SimulationManager manager = new SimulationManager("TestLargeConvolution");
        Dimension inputDimension = new Dimension(inputHeight, inputWidth, inputChannels);
        ArrayList<ArrayList<float[][]>> convKernels = generateRandomKernels(
                inputDimension, kernelDim, outputChannels);
        ArrayList<Float> biases = generateRandomBias(outputChannels);
        ConvolutionParameters convParams = new ConvolutionParameters(
                inputDimension, outputChannels,
                convKernels, biases);
        convParams.foldingFactor = 250;
        convParams.kernelFoldingFactor = 1;
        ConvolutionLayerKernel kernel = new ConvolutionLayerKernel(
                manager.makeKernelParameters(), convParams);

        // building the manager
        // manager.logInfo("Seed: %d", seed);
        manager.setKernel(kernel);
        manager.build();

        // computing expected values
        ArrayList<Double> doubleInput = generateRandomData(inputDimension);
        ArrayList<Double> doubleExpectedOutput = computeExpected(
                doubleInput, inputDimension, convKernels, biases);
        ArrayList<Bits> rawInput = toBitsInput(doubleInput, inputChannels);

        // running the kernel
        manager.setInputDataRaw("x", rawInput);
        manager.setKernelCycles(kernel.cyclesPerImage());
        manager.run();
        List<Bits> rawOutput = manager.getOutputDataRaw("y");
        List<Double> doubleOutput = toDoubleOutput(rawOutput, outputChannels);

        // check the results whether it is successful
        assertEquals(doubleOutput.size(), doubleExpectedOutput.size());

        for (int i = 0 ; i < doubleOutput.size() ; i++) {
            double d = Math.abs(doubleOutput[i] - doubleExpectedOutput[i]);
            assertTrue(d < 0.05);
        }
    }

    @Test
    public void testSmallConvolution() {
        final int inputHeight = 28;
        final int inputWidth = 28;
        final int inputChannels = 10;
        final int outputChannels = 20;

        SimulationManager manager = new SimulationManager("TestSmallConvolution");
        Dimension inputDimension = new Dimension(inputHeight, inputWidth, inputChannels);
        ConvolutionParameters convParams = new ConvolutionParameters(
                inputDimension, outputChannels,
                RB.loadConvolutionKernels(), RB.loadConvolutionBiases());
        ConvolutionLayerKernel kernel = new ConvolutionLayerKernel(
                manager.makeKernelParameters(), convParams);

        // manager.logInfo("Seed: %d", seed);
        manager.setKernel(kernel);
        manager.build();

        ArrayList<Double> ori_x = new ArrayList<Double>();

        for (int t = 0 ; t < 10 ; t++) {
            ArrayList<Double> inputData = RB.loadInputData(t);
            ArrayList<Double> expectedOutputData = RB.loadOutputData(t);
            List<Bits> inputBits = new ArrayList<Bits>();
            List<Bits> outputBits;

            for (int i = 0 ; i < inputData.size() / inputChannels ; i++) {
                Bits[] bitsArr = new Bits[inputChannels];

                for (int j = 0 ; j < inputChannels ; j++) {
                    int idx = i * inputChannels + j;
                    bitsArr[j] = Utils.doubleToBits(inputData[idx]);
                }

                inputBits.add(Utils.concatBits(bitsArr));
            }

            manager.setInputDataRaw("x", inputBits);
            manager.setKernelCycles(kernel.cyclesPerImage());
            manager.run();
            outputBits = manager.getOutputDataRaw("y");

            assertTrue(expectedOutputData.size() / outputBits.size() == outputChannels);
            assertTrue(expectedOutputData.size() % outputBits.size() == 0 );

            for (int i = 0 ; i < outputBits.size() ; i++) {
                for (int j = 0 ; j < outputChannels ; j++) {
                    int totalBits = GlobalConfig.intBits + GlobalConfig.fracBits;
                    Bits b = Utils.subBits(outputBits[i], j * totalBits, totalBits);

                    double d = Math.abs(
                            expectedOutputData[i * outputChannels + j]  - Utils.bitsToDouble(b));

                    assertTrue(d < 0.05);
                }
            }
        }
    }
}

